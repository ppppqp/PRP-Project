{"ast":null,"code":"// https://github.com/topojson/topojson Version 3.0.2. Copyright 2017 Mike Bostock.\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.topojson = global.topojson || {});\n})(this, function (exports) {\n  'use strict';\n\n  var identity = function (x) {\n    return x;\n  };\n\n  var transform = function (transform) {\n    if (transform == null) return identity;\n    var x0,\n        y0,\n        kx = transform.scale[0],\n        ky = transform.scale[1],\n        dx = transform.translate[0],\n        dy = transform.translate[1];\n    return function (input, i) {\n      if (!i) x0 = y0 = 0;\n      var j = 2,\n          n = input.length,\n          output = new Array(n);\n      output[0] = (x0 += input[0]) * kx + dx;\n      output[1] = (y0 += input[1]) * ky + dy;\n\n      while (j < n) output[j] = input[j], ++j;\n\n      return output;\n    };\n  };\n\n  var bbox = function (topology) {\n    var t = transform(topology.transform),\n        key,\n        x0 = Infinity,\n        y0 = x0,\n        x1 = -x0,\n        y1 = -x0;\n\n    function bboxPoint(p) {\n      p = t(p);\n      if (p[0] < x0) x0 = p[0];\n      if (p[0] > x1) x1 = p[0];\n      if (p[1] < y0) y0 = p[1];\n      if (p[1] > y1) y1 = p[1];\n    }\n\n    function bboxGeometry(o) {\n      switch (o.type) {\n        case \"GeometryCollection\":\n          o.geometries.forEach(bboxGeometry);\n          break;\n\n        case \"Point\":\n          bboxPoint(o.coordinates);\n          break;\n\n        case \"MultiPoint\":\n          o.coordinates.forEach(bboxPoint);\n          break;\n      }\n    }\n\n    topology.arcs.forEach(function (arc) {\n      var i = -1,\n          n = arc.length,\n          p;\n\n      while (++i < n) {\n        p = t(arc[i], i);\n        if (p[0] < x0) x0 = p[0];\n        if (p[0] > x1) x1 = p[0];\n        if (p[1] < y0) y0 = p[1];\n        if (p[1] > y1) y1 = p[1];\n      }\n    });\n\n    for (key in topology.objects) {\n      bboxGeometry(topology.objects[key]);\n    }\n\n    return [x0, y0, x1, y1];\n  };\n\n  var reverse = function (array, n) {\n    var t,\n        j = array.length,\n        i = j - n;\n\n    while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n  };\n\n  var feature = function (topology, o) {\n    return o.type === \"GeometryCollection\" ? {\n      type: \"FeatureCollection\",\n      features: o.geometries.map(function (o) {\n        return feature$1(topology, o);\n      })\n    } : feature$1(topology, o);\n  };\n\n  function feature$1(topology, o) {\n    var id = o.id,\n        bbox = o.bbox,\n        properties = o.properties == null ? {} : o.properties,\n        geometry = object(topology, o);\n    return id == null && bbox == null ? {\n      type: \"Feature\",\n      properties: properties,\n      geometry: geometry\n    } : bbox == null ? {\n      type: \"Feature\",\n      id: id,\n      properties: properties,\n      geometry: geometry\n    } : {\n      type: \"Feature\",\n      id: id,\n      bbox: bbox,\n      properties: properties,\n      geometry: geometry\n    };\n  }\n\n  function object(topology, o) {\n    var transformPoint = transform(topology.transform),\n        arcs = topology.arcs;\n\n    function arc(i, points) {\n      if (points.length) points.pop();\n\n      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n        points.push(transformPoint(a[k], k));\n      }\n\n      if (i < 0) reverse(points, n);\n    }\n\n    function point(p) {\n      return transformPoint(p);\n    }\n\n    function line(arcs) {\n      var points = [];\n\n      for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n\n      if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n\n      return points;\n    }\n\n    function ring(arcs) {\n      var points = line(arcs);\n\n      while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.\n\n\n      return points;\n    }\n\n    function polygon(arcs) {\n      return arcs.map(ring);\n    }\n\n    function geometry(o) {\n      var type = o.type,\n          coordinates;\n\n      switch (type) {\n        case \"GeometryCollection\":\n          return {\n            type: type,\n            geometries: o.geometries.map(geometry)\n          };\n\n        case \"Point\":\n          coordinates = point(o.coordinates);\n          break;\n\n        case \"MultiPoint\":\n          coordinates = o.coordinates.map(point);\n          break;\n\n        case \"LineString\":\n          coordinates = line(o.arcs);\n          break;\n\n        case \"MultiLineString\":\n          coordinates = o.arcs.map(line);\n          break;\n\n        case \"Polygon\":\n          coordinates = polygon(o.arcs);\n          break;\n\n        case \"MultiPolygon\":\n          coordinates = o.arcs.map(polygon);\n          break;\n\n        default:\n          return null;\n      }\n\n      return {\n        type: type,\n        coordinates: coordinates\n      };\n    }\n\n    return geometry(o);\n  }\n\n  var stitch = function (topology, arcs) {\n    var stitchedArcs = {},\n        fragmentByStart = {},\n        fragmentByEnd = {},\n        fragments = [],\n        emptyIndex = -1; // Stitch empty arcs first, since they may be subsumed by other arcs.\n\n    arcs.forEach(function (i, j) {\n      var arc = topology.arcs[i < 0 ? ~i : i],\n          t;\n\n      if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n        t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n      }\n    });\n    arcs.forEach(function (i) {\n      var e = ends(i),\n          start = e[0],\n          end = e[1],\n          f,\n          g;\n\n      if (f = fragmentByEnd[start]) {\n        delete fragmentByEnd[f.end];\n        f.push(i);\n        f.end = end;\n\n        if (g = fragmentByStart[end]) {\n          delete fragmentByStart[g.start];\n          var fg = g === f ? f : f.concat(g);\n          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n        } else {\n          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n        }\n      } else if (f = fragmentByStart[end]) {\n        delete fragmentByStart[f.start];\n        f.unshift(i);\n        f.start = start;\n\n        if (g = fragmentByEnd[start]) {\n          delete fragmentByEnd[g.end];\n          var gf = g === f ? f : g.concat(f);\n          fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n        } else {\n          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n        }\n      } else {\n        f = [i];\n        fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n      }\n    });\n\n    function ends(i) {\n      var arc = topology.arcs[i < 0 ? ~i : i],\n          p0 = arc[0],\n          p1;\n      if (topology.transform) p1 = [0, 0], arc.forEach(function (dp) {\n        p1[0] += dp[0], p1[1] += dp[1];\n      });else p1 = arc[arc.length - 1];\n      return i < 0 ? [p1, p0] : [p0, p1];\n    }\n\n    function flush(fragmentByEnd, fragmentByStart) {\n      for (var k in fragmentByEnd) {\n        var f = fragmentByEnd[k];\n        delete fragmentByStart[f.start];\n        delete f.start;\n        delete f.end;\n        f.forEach(function (i) {\n          stitchedArcs[i < 0 ? ~i : i] = 1;\n        });\n        fragments.push(f);\n      }\n    }\n\n    flush(fragmentByEnd, fragmentByStart);\n    flush(fragmentByStart, fragmentByEnd);\n    arcs.forEach(function (i) {\n      if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]);\n    });\n    return fragments;\n  };\n\n  var mesh = function (topology) {\n    return object(topology, meshArcs.apply(this, arguments));\n  };\n\n  function meshArcs(topology, object$$1, filter) {\n    var arcs, i, n;\n    if (arguments.length > 1) arcs = extractArcs(topology, object$$1, filter);else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;\n    return {\n      type: \"MultiLineString\",\n      arcs: stitch(topology, arcs)\n    };\n  }\n\n  function extractArcs(topology, object$$1, filter) {\n    var arcs = [],\n        geomsByArc = [],\n        geom;\n\n    function extract0(i) {\n      var j = i < 0 ? ~i : i;\n      (geomsByArc[j] || (geomsByArc[j] = [])).push({\n        i: i,\n        g: geom\n      });\n    }\n\n    function extract1(arcs) {\n      arcs.forEach(extract0);\n    }\n\n    function extract2(arcs) {\n      arcs.forEach(extract1);\n    }\n\n    function extract3(arcs) {\n      arcs.forEach(extract2);\n    }\n\n    function geometry(o) {\n      switch (geom = o, o.type) {\n        case \"GeometryCollection\":\n          o.geometries.forEach(geometry);\n          break;\n\n        case \"LineString\":\n          extract1(o.arcs);\n          break;\n\n        case \"MultiLineString\":\n        case \"Polygon\":\n          extract2(o.arcs);\n          break;\n\n        case \"MultiPolygon\":\n          extract3(o.arcs);\n          break;\n      }\n    }\n\n    geometry(object$$1);\n    geomsByArc.forEach(filter == null ? function (geoms) {\n      arcs.push(geoms[0].i);\n    } : function (geoms) {\n      if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i);\n    });\n    return arcs;\n  }\n\n  function planarRingArea(ring) {\n    var i = -1,\n        n = ring.length,\n        a,\n        b = ring[n - 1],\n        area = 0;\n\n    while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n\n    return Math.abs(area); // Note: doubled area!\n  }\n\n  var merge = function (topology) {\n    return object(topology, mergeArcs.apply(this, arguments));\n  };\n\n  function mergeArcs(topology, objects) {\n    var polygonsByArc = {},\n        polygons = [],\n        groups = [];\n    objects.forEach(geometry);\n\n    function geometry(o) {\n      switch (o.type) {\n        case \"GeometryCollection\":\n          o.geometries.forEach(geometry);\n          break;\n\n        case \"Polygon\":\n          extract(o.arcs);\n          break;\n\n        case \"MultiPolygon\":\n          o.arcs.forEach(extract);\n          break;\n      }\n    }\n\n    function extract(polygon) {\n      polygon.forEach(function (ring) {\n        ring.forEach(function (arc) {\n          (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n        });\n      });\n      polygons.push(polygon);\n    }\n\n    function area(ring) {\n      return planarRingArea(object(topology, {\n        type: \"Polygon\",\n        arcs: [ring]\n      }).coordinates[0]);\n    }\n\n    polygons.forEach(function (polygon) {\n      if (!polygon._) {\n        var group = [],\n            neighbors = [polygon];\n        polygon._ = 1;\n        groups.push(group);\n\n        while (polygon = neighbors.pop()) {\n          group.push(polygon);\n          polygon.forEach(function (ring) {\n            ring.forEach(function (arc) {\n              polygonsByArc[arc < 0 ? ~arc : arc].forEach(function (polygon) {\n                if (!polygon._) {\n                  polygon._ = 1;\n                  neighbors.push(polygon);\n                }\n              });\n            });\n          });\n        }\n      }\n    });\n    polygons.forEach(function (polygon) {\n      delete polygon._;\n    });\n    return {\n      type: \"MultiPolygon\",\n      arcs: groups.map(function (polygons) {\n        var arcs = [],\n            n; // Extract the exterior (unique) arcs.\n\n        polygons.forEach(function (polygon) {\n          polygon.forEach(function (ring) {\n            ring.forEach(function (arc) {\n              if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n                arcs.push(arc);\n              }\n            });\n          });\n        }); // Stitch the arcs into one or more rings.\n\n        arcs = stitch(topology, arcs); // If more than one ring is returned,\n        // at most one of these rings can be the exterior;\n        // choose the one with the greatest absolute area.\n\n        if ((n = arcs.length) > 1) {\n          for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n            if ((ki = area(arcs[i])) > k) {\n              t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n            }\n          }\n        }\n\n        return arcs;\n      })\n    };\n  }\n\n  var bisect = function (a, x) {\n    var lo = 0,\n        hi = a.length;\n\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (a[mid] < x) lo = mid + 1;else hi = mid;\n    }\n\n    return lo;\n  };\n\n  var neighbors = function (objects) {\n    var indexesByArc = {},\n        // arc index -> array of object indexes\n    neighbors = objects.map(function () {\n      return [];\n    });\n\n    function line(arcs, i) {\n      arcs.forEach(function (a) {\n        if (a < 0) a = ~a;\n        var o = indexesByArc[a];\n        if (o) o.push(i);else indexesByArc[a] = [i];\n      });\n    }\n\n    function polygon(arcs, i) {\n      arcs.forEach(function (arc) {\n        line(arc, i);\n      });\n    }\n\n    function geometry(o, i) {\n      if (o.type === \"GeometryCollection\") o.geometries.forEach(function (o) {\n        geometry(o, i);\n      });else if (o.type in geometryType) geometryType[o.type](o.arcs, i);\n    }\n\n    var geometryType = {\n      LineString: line,\n      MultiLineString: polygon,\n      Polygon: polygon,\n      MultiPolygon: function (arcs, i) {\n        arcs.forEach(function (arc) {\n          polygon(arc, i);\n        });\n      }\n    };\n    objects.forEach(geometry);\n\n    for (var i in indexesByArc) {\n      for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {\n        for (var k = j + 1; k < m; ++k) {\n          var ij = indexes[j],\n              ik = indexes[k],\n              n;\n          if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);\n          if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);\n        }\n      }\n    }\n\n    return neighbors;\n  };\n\n  var untransform = function (transform) {\n    if (transform == null) return identity;\n    var x0,\n        y0,\n        kx = transform.scale[0],\n        ky = transform.scale[1],\n        dx = transform.translate[0],\n        dy = transform.translate[1];\n    return function (input, i) {\n      if (!i) x0 = y0 = 0;\n      var j = 2,\n          n = input.length,\n          output = new Array(n),\n          x1 = Math.round((input[0] - dx) / kx),\n          y1 = Math.round((input[1] - dy) / ky);\n      output[0] = x1 - x0, x0 = x1;\n      output[1] = y1 - y0, y0 = y1;\n\n      while (j < n) output[j] = input[j], ++j;\n\n      return output;\n    };\n  };\n\n  var quantize = function (topology, transform) {\n    if (topology.transform) throw new Error(\"already quantized\");\n\n    if (!transform || !transform.scale) {\n      if (!((n = Math.floor(transform)) >= 2)) throw new Error(\"n must be \\u22652\");\n      box = topology.bbox || bbox(topology);\n      var x0 = box[0],\n          y0 = box[1],\n          x1 = box[2],\n          y1 = box[3],\n          n;\n      transform = {\n        scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1],\n        translate: [x0, y0]\n      };\n    } else {\n      box = topology.bbox;\n    }\n\n    var t = untransform(transform),\n        box,\n        key,\n        inputs = topology.objects,\n        outputs = {};\n\n    function quantizePoint(point) {\n      return t(point);\n    }\n\n    function quantizeGeometry(input) {\n      var output;\n\n      switch (input.type) {\n        case \"GeometryCollection\":\n          output = {\n            type: \"GeometryCollection\",\n            geometries: input.geometries.map(quantizeGeometry)\n          };\n          break;\n\n        case \"Point\":\n          output = {\n            type: \"Point\",\n            coordinates: quantizePoint(input.coordinates)\n          };\n          break;\n\n        case \"MultiPoint\":\n          output = {\n            type: \"MultiPoint\",\n            coordinates: input.coordinates.map(quantizePoint)\n          };\n          break;\n\n        default:\n          return input;\n      }\n\n      if (input.id != null) output.id = input.id;\n      if (input.bbox != null) output.bbox = input.bbox;\n      if (input.properties != null) output.properties = input.properties;\n      return output;\n    }\n\n    function quantizeArc(input) {\n      var i = 0,\n          j = 1,\n          n = input.length,\n          p,\n          output = new Array(n); // pessimistic\n\n      output[0] = t(input[0], 0);\n\n      while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points\n\n\n      if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points\n\n      output.length = j;\n      return output;\n    }\n\n    for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);\n\n    return {\n      type: \"Topology\",\n      bbox: box,\n      transform: transform,\n      objects: outputs,\n      arcs: topology.arcs.map(quantizeArc)\n    };\n  }; // Computes the bounding box of the specified hash of GeoJSON objects.\n\n\n  var bounds = function (objects) {\n    var x0 = Infinity,\n        y0 = Infinity,\n        x1 = -Infinity,\n        y1 = -Infinity;\n\n    function boundGeometry(geometry) {\n      if (geometry != null && boundGeometryType.hasOwnProperty(geometry.type)) boundGeometryType[geometry.type](geometry);\n    }\n\n    var boundGeometryType = {\n      GeometryCollection: function (o) {\n        o.geometries.forEach(boundGeometry);\n      },\n      Point: function (o) {\n        boundPoint(o.coordinates);\n      },\n      MultiPoint: function (o) {\n        o.coordinates.forEach(boundPoint);\n      },\n      LineString: function (o) {\n        boundLine(o.arcs);\n      },\n      MultiLineString: function (o) {\n        o.arcs.forEach(boundLine);\n      },\n      Polygon: function (o) {\n        o.arcs.forEach(boundLine);\n      },\n      MultiPolygon: function (o) {\n        o.arcs.forEach(boundMultiLine);\n      }\n    };\n\n    function boundPoint(coordinates) {\n      var x = coordinates[0],\n          y = coordinates[1];\n      if (x < x0) x0 = x;\n      if (x > x1) x1 = x;\n      if (y < y0) y0 = y;\n      if (y > y1) y1 = y;\n    }\n\n    function boundLine(coordinates) {\n      coordinates.forEach(boundPoint);\n    }\n\n    function boundMultiLine(coordinates) {\n      coordinates.forEach(boundLine);\n    }\n\n    for (var key in objects) {\n      boundGeometry(objects[key]);\n    }\n\n    return x1 >= x0 && y1 >= y0 ? [x0, y0, x1, y1] : undefined;\n  };\n\n  var hashset = function (size, hash, equal, type, empty) {\n    if (arguments.length === 3) {\n      type = Array;\n      empty = null;\n    }\n\n    var store = new type(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),\n        mask = size - 1;\n\n    for (var i = 0; i < size; ++i) {\n      store[i] = empty;\n    }\n\n    function add(value) {\n      var index = hash(value) & mask,\n          match = store[index],\n          collisions = 0;\n\n      while (match != empty) {\n        if (equal(match, value)) return true;\n        if (++collisions >= size) throw new Error(\"full hashset\");\n        match = store[index = index + 1 & mask];\n      }\n\n      store[index] = value;\n      return true;\n    }\n\n    function has(value) {\n      var index = hash(value) & mask,\n          match = store[index],\n          collisions = 0;\n\n      while (match != empty) {\n        if (equal(match, value)) return true;\n        if (++collisions >= size) break;\n        match = store[index = index + 1 & mask];\n      }\n\n      return false;\n    }\n\n    function values() {\n      var values = [];\n\n      for (var i = 0, n = store.length; i < n; ++i) {\n        var match = store[i];\n        if (match != empty) values.push(match);\n      }\n\n      return values;\n    }\n\n    return {\n      add: add,\n      has: has,\n      values: values\n    };\n  };\n\n  var hashmap = function (size, hash, equal, keyType, keyEmpty, valueType) {\n    if (arguments.length === 3) {\n      keyType = valueType = Array;\n      keyEmpty = null;\n    }\n\n    var keystore = new keyType(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),\n        valstore = new valueType(size),\n        mask = size - 1;\n\n    for (var i = 0; i < size; ++i) {\n      keystore[i] = keyEmpty;\n    }\n\n    function set(key, value) {\n      var index = hash(key) & mask,\n          matchKey = keystore[index],\n          collisions = 0;\n\n      while (matchKey != keyEmpty) {\n        if (equal(matchKey, key)) return valstore[index] = value;\n        if (++collisions >= size) throw new Error(\"full hashmap\");\n        matchKey = keystore[index = index + 1 & mask];\n      }\n\n      keystore[index] = key;\n      valstore[index] = value;\n      return value;\n    }\n\n    function maybeSet(key, value) {\n      var index = hash(key) & mask,\n          matchKey = keystore[index],\n          collisions = 0;\n\n      while (matchKey != keyEmpty) {\n        if (equal(matchKey, key)) return valstore[index];\n        if (++collisions >= size) throw new Error(\"full hashmap\");\n        matchKey = keystore[index = index + 1 & mask];\n      }\n\n      keystore[index] = key;\n      valstore[index] = value;\n      return value;\n    }\n\n    function get(key, missingValue) {\n      var index = hash(key) & mask,\n          matchKey = keystore[index],\n          collisions = 0;\n\n      while (matchKey != keyEmpty) {\n        if (equal(matchKey, key)) return valstore[index];\n        if (++collisions >= size) break;\n        matchKey = keystore[index = index + 1 & mask];\n      }\n\n      return missingValue;\n    }\n\n    function keys() {\n      var keys = [];\n\n      for (var i = 0, n = keystore.length; i < n; ++i) {\n        var matchKey = keystore[i];\n        if (matchKey != keyEmpty) keys.push(matchKey);\n      }\n\n      return keys;\n    }\n\n    return {\n      set: set,\n      maybeSet: maybeSet,\n      // set if unset\n      get: get,\n      keys: keys\n    };\n  };\n\n  var equalPoint = function (pointA, pointB) {\n    return pointA[0] === pointB[0] && pointA[1] === pointB[1];\n  }; // TODO if quantized, use simpler Int32 hashing?\n\n\n  var buffer = new ArrayBuffer(16);\n  var uints = new Uint32Array(buffer);\n\n  var hashPoint = function (point) {\n    var hash = uints[0] ^ uints[1];\n    hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];\n    return hash & 0x7fffffff;\n  }; // Given an extracted (pre-)topology, identifies all of the junctions. These are\n  // the points at which arcs (lines or rings) will need to be cut so that each\n  // arc is represented uniquely.\n  //\n  // A junction is a point where at least one arc deviates from another arc going\n  // through the same point. For example, consider the point B. If there is a arc\n  // through ABC and another arc through CBA, then B is not a junction because in\n  // both cases the adjacent point pairs are {A,C}. However, if there is an\n  // additional arc ABD, then {A,D} != {A,C}, and thus B becomes a junction.\n  //\n  // For a closed ring ABCA, the first point A’s adjacent points are the second\n  // and last point {B,C}. For a line, the first and last point are always\n  // considered junctions, even if the line is closed; this ensures that a closed\n  // line is never rotated.\n\n\n  var join = function (topology) {\n    var coordinates = topology.coordinates,\n        lines = topology.lines,\n        rings = topology.rings,\n        indexes = index(),\n        visitedByIndex = new Int32Array(coordinates.length),\n        leftByIndex = new Int32Array(coordinates.length),\n        rightByIndex = new Int32Array(coordinates.length),\n        junctionByIndex = new Int8Array(coordinates.length),\n        junctionCount = 0,\n        // upper bound on number of junctions\n    i,\n        n,\n        previousIndex,\n        currentIndex,\n        nextIndex;\n\n    for (i = 0, n = coordinates.length; i < n; ++i) {\n      visitedByIndex[i] = leftByIndex[i] = rightByIndex[i] = -1;\n    }\n\n    for (i = 0, n = lines.length; i < n; ++i) {\n      var line = lines[i],\n          lineStart = line[0],\n          lineEnd = line[1];\n      currentIndex = indexes[lineStart];\n      nextIndex = indexes[++lineStart];\n      ++junctionCount, junctionByIndex[currentIndex] = 1; // start\n\n      while (++lineStart <= lineEnd) {\n        sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[lineStart]);\n      }\n\n      ++junctionCount, junctionByIndex[nextIndex] = 1; // end\n    }\n\n    for (i = 0, n = coordinates.length; i < n; ++i) {\n      visitedByIndex[i] = -1;\n    }\n\n    for (i = 0, n = rings.length; i < n; ++i) {\n      var ring = rings[i],\n          ringStart = ring[0] + 1,\n          ringEnd = ring[1];\n      previousIndex = indexes[ringEnd - 1];\n      currentIndex = indexes[ringStart - 1];\n      nextIndex = indexes[ringStart];\n      sequence(i, previousIndex, currentIndex, nextIndex);\n\n      while (++ringStart <= ringEnd) {\n        sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[ringStart]);\n      }\n    }\n\n    function sequence(i, previousIndex, currentIndex, nextIndex) {\n      if (visitedByIndex[currentIndex] === i) return; // ignore self-intersection\n\n      visitedByIndex[currentIndex] = i;\n      var leftIndex = leftByIndex[currentIndex];\n\n      if (leftIndex >= 0) {\n        var rightIndex = rightByIndex[currentIndex];\n\n        if ((leftIndex !== previousIndex || rightIndex !== nextIndex) && (leftIndex !== nextIndex || rightIndex !== previousIndex)) {\n          ++junctionCount, junctionByIndex[currentIndex] = 1;\n        }\n      } else {\n        leftByIndex[currentIndex] = previousIndex;\n        rightByIndex[currentIndex] = nextIndex;\n      }\n    }\n\n    function index() {\n      var indexByPoint = hashmap(coordinates.length * 1.4, hashIndex, equalIndex, Int32Array, -1, Int32Array),\n          indexes = new Int32Array(coordinates.length);\n\n      for (var i = 0, n = coordinates.length; i < n; ++i) {\n        indexes[i] = indexByPoint.maybeSet(i, i);\n      }\n\n      return indexes;\n    }\n\n    function hashIndex(i) {\n      return hashPoint(coordinates[i]);\n    }\n\n    function equalIndex(i, j) {\n      return equalPoint(coordinates[i], coordinates[j]);\n    }\n\n    visitedByIndex = leftByIndex = rightByIndex = null;\n    var junctionByPoint = hashset(junctionCount * 1.4, hashPoint, equalPoint),\n        j; // Convert back to a standard hashset by point for caller convenience.\n\n    for (i = 0, n = coordinates.length; i < n; ++i) {\n      if (junctionByIndex[j = indexes[i]]) {\n        junctionByPoint.add(coordinates[j]);\n      }\n    }\n\n    return junctionByPoint;\n  }; // Given an extracted (pre-)topology, cuts (or rotates) arcs so that all shared\n  // point sequences are identified. The topology can then be subsequently deduped\n  // to remove exact duplicate arcs.\n\n\n  var cut = function (topology) {\n    var junctions = join(topology),\n        coordinates = topology.coordinates,\n        lines = topology.lines,\n        rings = topology.rings,\n        next,\n        i,\n        n;\n\n    for (i = 0, n = lines.length; i < n; ++i) {\n      var line = lines[i],\n          lineMid = line[0],\n          lineEnd = line[1];\n\n      while (++lineMid < lineEnd) {\n        if (junctions.has(coordinates[lineMid])) {\n          next = {\n            0: lineMid,\n            1: line[1]\n          };\n          line[1] = lineMid;\n          line = line.next = next;\n        }\n      }\n    }\n\n    for (i = 0, n = rings.length; i < n; ++i) {\n      var ring = rings[i],\n          ringStart = ring[0],\n          ringMid = ringStart,\n          ringEnd = ring[1],\n          ringFixed = junctions.has(coordinates[ringStart]);\n\n      while (++ringMid < ringEnd) {\n        if (junctions.has(coordinates[ringMid])) {\n          if (ringFixed) {\n            next = {\n              0: ringMid,\n              1: ring[1]\n            };\n            ring[1] = ringMid;\n            ring = ring.next = next;\n          } else {\n            // For the first junction, we can rotate rather than cut.\n            rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);\n            coordinates[ringEnd] = coordinates[ringStart];\n            ringFixed = true;\n            ringMid = ringStart; // restart; we may have skipped junctions\n          }\n        }\n      }\n    }\n\n    return topology;\n  };\n\n  function rotateArray(array, start, end, offset) {\n    reverse$1(array, start, end);\n    reverse$1(array, start, start + offset);\n    reverse$1(array, start + offset, end);\n  }\n\n  function reverse$1(array, start, end) {\n    for (var mid = start + (end-- - start >> 1), t; start < mid; ++start, --end) {\n      t = array[start], array[start] = array[end], array[end] = t;\n    }\n  } // Given a cut topology, combines duplicate arcs.\n\n\n  var dedup = function (topology) {\n    var coordinates = topology.coordinates,\n        lines = topology.lines,\n        line,\n        rings = topology.rings,\n        ring,\n        arcCount = lines.length + rings.length,\n        i,\n        n;\n    delete topology.lines;\n    delete topology.rings; // Count the number of (non-unique) arcs to initialize the hashmap safely.\n\n    for (i = 0, n = lines.length; i < n; ++i) {\n      line = lines[i];\n\n      while (line = line.next) ++arcCount;\n    }\n\n    for (i = 0, n = rings.length; i < n; ++i) {\n      ring = rings[i];\n\n      while (ring = ring.next) ++arcCount;\n    }\n\n    var arcsByEnd = hashmap(arcCount * 2 * 1.4, hashPoint, equalPoint),\n        arcs = topology.arcs = [];\n\n    for (i = 0, n = lines.length; i < n; ++i) {\n      line = lines[i];\n\n      do {\n        dedupLine(line);\n      } while (line = line.next);\n    }\n\n    for (i = 0, n = rings.length; i < n; ++i) {\n      ring = rings[i];\n\n      if (ring.next) {\n        // arc is no longer closed\n        do {\n          dedupLine(ring);\n        } while (ring = ring.next);\n      } else {\n        dedupRing(ring);\n      }\n    }\n\n    function dedupLine(arc) {\n      var startPoint, endPoint, startArcs, startArc, endArcs, endArc, i, n; // Does this arc match an existing arc in order?\n\n      if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {\n        for (i = 0, n = startArcs.length; i < n; ++i) {\n          startArc = startArcs[i];\n\n          if (equalLine(startArc, arc)) {\n            arc[0] = startArc[0];\n            arc[1] = startArc[1];\n            return;\n          }\n        }\n      } // Does this arc match an existing arc in reverse order?\n\n\n      if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {\n        for (i = 0, n = endArcs.length; i < n; ++i) {\n          endArc = endArcs[i];\n\n          if (reverseEqualLine(endArc, arc)) {\n            arc[1] = endArc[0];\n            arc[0] = endArc[1];\n            return;\n          }\n        }\n      }\n\n      if (startArcs) startArcs.push(arc);else arcsByEnd.set(startPoint, [arc]);\n      if (endArcs) endArcs.push(arc);else arcsByEnd.set(endPoint, [arc]);\n      arcs.push(arc);\n    }\n\n    function dedupRing(arc) {\n      var endPoint, endArcs, endArc, i, n; // Does this arc match an existing line in order, or reverse order?\n      // Rings are closed, so their start point and end point is the same.\n\n      if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {\n        for (i = 0, n = endArcs.length; i < n; ++i) {\n          endArc = endArcs[i];\n\n          if (equalRing(endArc, arc)) {\n            arc[0] = endArc[0];\n            arc[1] = endArc[1];\n            return;\n          }\n\n          if (reverseEqualRing(endArc, arc)) {\n            arc[0] = endArc[1];\n            arc[1] = endArc[0];\n            return;\n          }\n        }\n      } // Otherwise, does this arc match an existing ring in order, or reverse order?\n\n\n      if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {\n        for (i = 0, n = endArcs.length; i < n; ++i) {\n          endArc = endArcs[i];\n\n          if (equalRing(endArc, arc)) {\n            arc[0] = endArc[0];\n            arc[1] = endArc[1];\n            return;\n          }\n\n          if (reverseEqualRing(endArc, arc)) {\n            arc[0] = endArc[1];\n            arc[1] = endArc[0];\n            return;\n          }\n        }\n      }\n\n      if (endArcs) endArcs.push(arc);else arcsByEnd.set(endPoint, [arc]);\n      arcs.push(arc);\n    }\n\n    function equalLine(arcA, arcB) {\n      var ia = arcA[0],\n          ib = arcB[0],\n          ja = arcA[1],\n          jb = arcB[1];\n      if (ia - ja !== ib - jb) return false;\n\n      for (; ia <= ja; ++ia, ++ib) if (!equalPoint(coordinates[ia], coordinates[ib])) return false;\n\n      return true;\n    }\n\n    function reverseEqualLine(arcA, arcB) {\n      var ia = arcA[0],\n          ib = arcB[0],\n          ja = arcA[1],\n          jb = arcB[1];\n      if (ia - ja !== ib - jb) return false;\n\n      for (; ia <= ja; ++ia, --jb) if (!equalPoint(coordinates[ia], coordinates[jb])) return false;\n\n      return true;\n    }\n\n    function equalRing(arcA, arcB) {\n      var ia = arcA[0],\n          ib = arcB[0],\n          ja = arcA[1],\n          jb = arcB[1],\n          n = ja - ia;\n      if (n !== jb - ib) return false;\n      var ka = findMinimumOffset(arcA),\n          kb = findMinimumOffset(arcB);\n\n      for (var i = 0; i < n; ++i) {\n        if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[ib + (i + kb) % n])) return false;\n      }\n\n      return true;\n    }\n\n    function reverseEqualRing(arcA, arcB) {\n      var ia = arcA[0],\n          ib = arcB[0],\n          ja = arcA[1],\n          jb = arcB[1],\n          n = ja - ia;\n      if (n !== jb - ib) return false;\n      var ka = findMinimumOffset(arcA),\n          kb = n - findMinimumOffset(arcB);\n\n      for (var i = 0; i < n; ++i) {\n        if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[jb - (i + kb) % n])) return false;\n      }\n\n      return true;\n    } // Rings are rotated to a consistent, but arbitrary, start point.\n    // This is necessary to detect when a ring and a rotated copy are dupes.\n\n\n    function findMinimumOffset(arc) {\n      var start = arc[0],\n          end = arc[1],\n          mid = start,\n          minimum = mid,\n          minimumPoint = coordinates[mid];\n\n      while (++mid < end) {\n        var point = coordinates[mid];\n\n        if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {\n          minimum = mid;\n          minimumPoint = point;\n        }\n      }\n\n      return minimum - start;\n    }\n\n    return topology;\n  }; // Given an array of arcs in absolute (but already quantized!) coordinates,\n  // converts to fixed-point delta encoding.\n  // This is a destructive operation that modifies the given arcs!\n\n\n  var delta = function (arcs) {\n    var i = -1,\n        n = arcs.length;\n\n    while (++i < n) {\n      var arc = arcs[i],\n          j = 0,\n          k = 1,\n          m = arc.length,\n          point = arc[0],\n          x0 = point[0],\n          y0 = point[1],\n          x1,\n          y1;\n\n      while (++j < m) {\n        point = arc[j], x1 = point[0], y1 = point[1];\n        if (x1 !== x0 || y1 !== y0) arc[k++] = [x1 - x0, y1 - y0], x0 = x1, y0 = y1;\n      }\n\n      if (k === 1) arc[k++] = [0, 0]; // Each arc must be an array of two or more positions.\n\n      arc.length = k;\n    }\n\n    return arcs;\n  }; // Extracts the lines and rings from the specified hash of geometry objects.\n  //\n  // Returns an object with three properties:\n  //\n  // * coordinates - shared buffer of [x, y] coordinates\n  // * lines - lines extracted from the hash, of the form [start, end]\n  // * rings - rings extracted from the hash, of the form [start, end]\n  //\n  // For each ring or line, start and end represent inclusive indexes into the\n  // coordinates buffer. For rings (and closed lines), coordinates[start] equals\n  // coordinates[end].\n  //\n  // For each line or polygon geometry in the input hash, including nested\n  // geometries as in geometry collections, the `coordinates` array is replaced\n  // with an equivalent `arcs` array that, for each line (for line string\n  // geometries) or ring (for polygon geometries), points to one of the above\n  // lines or rings.\n\n\n  var extract = function (objects) {\n    var index = -1,\n        lines = [],\n        rings = [],\n        coordinates = [];\n\n    function extractGeometry(geometry) {\n      if (geometry && extractGeometryType.hasOwnProperty(geometry.type)) extractGeometryType[geometry.type](geometry);\n    }\n\n    var extractGeometryType = {\n      GeometryCollection: function (o) {\n        o.geometries.forEach(extractGeometry);\n      },\n      LineString: function (o) {\n        o.arcs = extractLine(o.arcs);\n      },\n      MultiLineString: function (o) {\n        o.arcs = o.arcs.map(extractLine);\n      },\n      Polygon: function (o) {\n        o.arcs = o.arcs.map(extractRing);\n      },\n      MultiPolygon: function (o) {\n        o.arcs = o.arcs.map(extractMultiRing);\n      }\n    };\n\n    function extractLine(line) {\n      for (var i = 0, n = line.length; i < n; ++i) coordinates[++index] = line[i];\n\n      var arc = {\n        0: index - n + 1,\n        1: index\n      };\n      lines.push(arc);\n      return arc;\n    }\n\n    function extractRing(ring) {\n      for (var i = 0, n = ring.length; i < n; ++i) coordinates[++index] = ring[i];\n\n      var arc = {\n        0: index - n + 1,\n        1: index\n      };\n      rings.push(arc);\n      return arc;\n    }\n\n    function extractMultiRing(rings) {\n      return rings.map(extractRing);\n    }\n\n    for (var key in objects) {\n      extractGeometry(objects[key]);\n    }\n\n    return {\n      type: \"Topology\",\n      coordinates: coordinates,\n      lines: lines,\n      rings: rings,\n      objects: objects\n    };\n  }; // Given a hash of GeoJSON objects, returns a hash of GeoJSON geometry objects.\n  // Any null input geometry objects are represented as {type: null} in the output.\n  // Any feature.{id,properties,bbox} are transferred to the output geometry object.\n  // Each output geometry object is a shallow copy of the input (e.g., properties, coordinates)!\n\n\n  var geometry = function (inputs) {\n    var outputs = {},\n        key;\n\n    for (key in inputs) outputs[key] = geomifyObject(inputs[key]);\n\n    return outputs;\n  };\n\n  function geomifyObject(input) {\n    return input == null ? {\n      type: null\n    } : (input.type === \"FeatureCollection\" ? geomifyFeatureCollection : input.type === \"Feature\" ? geomifyFeature : geomifyGeometry)(input);\n  }\n\n  function geomifyFeatureCollection(input) {\n    var output = {\n      type: \"GeometryCollection\",\n      geometries: input.features.map(geomifyFeature)\n    };\n    if (input.bbox != null) output.bbox = input.bbox;\n    return output;\n  }\n\n  function geomifyFeature(input) {\n    var output = geomifyGeometry(input.geometry),\n        key; // eslint-disable-line no-unused-vars\n\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n\n    for (key in input.properties) {\n      output.properties = input.properties;\n      break;\n    }\n\n    return output;\n  }\n\n  function geomifyGeometry(input) {\n    if (input == null) return {\n      type: null\n    };\n    var output = input.type === \"GeometryCollection\" ? {\n      type: \"GeometryCollection\",\n      geometries: input.geometries.map(geomifyGeometry)\n    } : input.type === \"Point\" || input.type === \"MultiPoint\" ? {\n      type: input.type,\n      coordinates: input.coordinates\n    } : {\n      type: input.type,\n      arcs: input.coordinates\n    }; // TODO Check for unknown types?\n\n    if (input.bbox != null) output.bbox = input.bbox;\n    return output;\n  }\n\n  var prequantize = function (objects, bbox, n) {\n    var x0 = bbox[0],\n        y0 = bbox[1],\n        x1 = bbox[2],\n        y1 = bbox[3],\n        kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1,\n        ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;\n\n    function quantizePoint(input) {\n      return [Math.round((input[0] - x0) * kx), Math.round((input[1] - y0) * ky)];\n    }\n\n    function quantizePoints(input, m) {\n      var i = -1,\n          j = 0,\n          n = input.length,\n          output = new Array(n),\n          // pessimistic\n      pi,\n          px,\n          py,\n          x,\n          y;\n\n      while (++i < n) {\n        pi = input[i];\n        x = Math.round((pi[0] - x0) * kx);\n        y = Math.round((pi[1] - y0) * ky);\n        if (x !== px || y !== py) output[j++] = [px = x, py = y]; // non-coincident points\n      }\n\n      output.length = j;\n\n      while (j < m) j = output.push([output[0][0], output[0][1]]);\n\n      return output;\n    }\n\n    function quantizeLine(input) {\n      return quantizePoints(input, 2);\n    }\n\n    function quantizeRing(input) {\n      return quantizePoints(input, 4);\n    }\n\n    function quantizePolygon(input) {\n      return input.map(quantizeRing);\n    }\n\n    function quantizeGeometry(o) {\n      if (o != null && quantizeGeometryType.hasOwnProperty(o.type)) quantizeGeometryType[o.type](o);\n    }\n\n    var quantizeGeometryType = {\n      GeometryCollection: function (o) {\n        o.geometries.forEach(quantizeGeometry);\n      },\n      Point: function (o) {\n        o.coordinates = quantizePoint(o.coordinates);\n      },\n      MultiPoint: function (o) {\n        o.coordinates = o.coordinates.map(quantizePoint);\n      },\n      LineString: function (o) {\n        o.arcs = quantizeLine(o.arcs);\n      },\n      MultiLineString: function (o) {\n        o.arcs = o.arcs.map(quantizeLine);\n      },\n      Polygon: function (o) {\n        o.arcs = quantizePolygon(o.arcs);\n      },\n      MultiPolygon: function (o) {\n        o.arcs = o.arcs.map(quantizePolygon);\n      }\n    };\n\n    for (var key in objects) {\n      quantizeGeometry(objects[key]);\n    }\n\n    return {\n      scale: [1 / kx, 1 / ky],\n      translate: [x0, y0]\n    };\n  }; // Constructs the TopoJSON Topology for the specified hash of features.\n  // Each object in the specified hash must be a GeoJSON object,\n  // meaning FeatureCollection, a Feature or a geometry object.\n\n\n  var topology = function (objects, quantization) {\n    var bbox = bounds(objects = geometry(objects)),\n        transform = quantization > 0 && bbox && prequantize(objects, bbox, quantization),\n        topology = dedup(cut(extract(objects))),\n        coordinates = topology.coordinates,\n        indexByArc = hashmap(topology.arcs.length * 1.4, hashArc, equalArc);\n    objects = topology.objects; // for garbage collection\n\n    topology.bbox = bbox;\n    topology.arcs = topology.arcs.map(function (arc, i) {\n      indexByArc.set(arc, i);\n      return coordinates.slice(arc[0], arc[1] + 1);\n    });\n    delete topology.coordinates;\n    coordinates = null;\n\n    function indexGeometry(geometry$$1) {\n      if (geometry$$1 && indexGeometryType.hasOwnProperty(geometry$$1.type)) indexGeometryType[geometry$$1.type](geometry$$1);\n    }\n\n    var indexGeometryType = {\n      GeometryCollection: function (o) {\n        o.geometries.forEach(indexGeometry);\n      },\n      LineString: function (o) {\n        o.arcs = indexArcs(o.arcs);\n      },\n      MultiLineString: function (o) {\n        o.arcs = o.arcs.map(indexArcs);\n      },\n      Polygon: function (o) {\n        o.arcs = o.arcs.map(indexArcs);\n      },\n      MultiPolygon: function (o) {\n        o.arcs = o.arcs.map(indexMultiArcs);\n      }\n    };\n\n    function indexArcs(arc) {\n      var indexes = [];\n\n      do {\n        var index = indexByArc.get(arc);\n        indexes.push(arc[0] < arc[1] ? index : ~index);\n      } while (arc = arc.next);\n\n      return indexes;\n    }\n\n    function indexMultiArcs(arcs) {\n      return arcs.map(indexArcs);\n    }\n\n    for (var key in objects) {\n      indexGeometry(objects[key]);\n    }\n\n    if (transform) {\n      topology.transform = transform;\n      topology.arcs = delta(topology.arcs);\n    }\n\n    return topology;\n  };\n\n  function hashArc(arc) {\n    var i = arc[0],\n        j = arc[1],\n        t;\n    if (j < i) t = i, i = j, j = t;\n    return i + 31 * j;\n  }\n\n  function equalArc(arcA, arcB) {\n    var ia = arcA[0],\n        ja = arcA[1],\n        ib = arcB[0],\n        jb = arcB[1],\n        t;\n    if (ja < ia) t = ia, ia = ja, ja = t;\n    if (jb < ib) t = ib, ib = jb, jb = t;\n    return ia === ib && ja === jb;\n  }\n\n  var prune = function (topology) {\n    var oldObjects = topology.objects,\n        newObjects = {},\n        oldArcs = topology.arcs,\n        oldArcsLength = oldArcs.length,\n        oldIndex = -1,\n        newIndexByOldIndex = new Array(oldArcsLength),\n        newArcsLength = 0,\n        newArcs,\n        newIndex = -1,\n        key;\n\n    function scanGeometry(input) {\n      switch (input.type) {\n        case \"GeometryCollection\":\n          input.geometries.forEach(scanGeometry);\n          break;\n\n        case \"LineString\":\n          scanArcs(input.arcs);\n          break;\n\n        case \"MultiLineString\":\n          input.arcs.forEach(scanArcs);\n          break;\n\n        case \"Polygon\":\n          input.arcs.forEach(scanArcs);\n          break;\n\n        case \"MultiPolygon\":\n          input.arcs.forEach(scanMultiArcs);\n          break;\n      }\n    }\n\n    function scanArc(index) {\n      if (index < 0) index = ~index;\n      if (!newIndexByOldIndex[index]) newIndexByOldIndex[index] = 1, ++newArcsLength;\n    }\n\n    function scanArcs(arcs) {\n      arcs.forEach(scanArc);\n    }\n\n    function scanMultiArcs(arcs) {\n      arcs.forEach(scanArcs);\n    }\n\n    function reindexGeometry(input) {\n      var output;\n\n      switch (input.type) {\n        case \"GeometryCollection\":\n          output = {\n            type: \"GeometryCollection\",\n            geometries: input.geometries.map(reindexGeometry)\n          };\n          break;\n\n        case \"LineString\":\n          output = {\n            type: \"LineString\",\n            arcs: reindexArcs(input.arcs)\n          };\n          break;\n\n        case \"MultiLineString\":\n          output = {\n            type: \"MultiLineString\",\n            arcs: input.arcs.map(reindexArcs)\n          };\n          break;\n\n        case \"Polygon\":\n          output = {\n            type: \"Polygon\",\n            arcs: input.arcs.map(reindexArcs)\n          };\n          break;\n\n        case \"MultiPolygon\":\n          output = {\n            type: \"MultiPolygon\",\n            arcs: input.arcs.map(reindexMultiArcs)\n          };\n          break;\n\n        default:\n          return input;\n      }\n\n      if (input.id != null) output.id = input.id;\n      if (input.bbox != null) output.bbox = input.bbox;\n      if (input.properties != null) output.properties = input.properties;\n      return output;\n    }\n\n    function reindexArc(oldIndex) {\n      return oldIndex < 0 ? ~newIndexByOldIndex[~oldIndex] : newIndexByOldIndex[oldIndex];\n    }\n\n    function reindexArcs(arcs) {\n      return arcs.map(reindexArc);\n    }\n\n    function reindexMultiArcs(arcs) {\n      return arcs.map(reindexArcs);\n    }\n\n    for (key in oldObjects) {\n      scanGeometry(oldObjects[key]);\n    }\n\n    newArcs = new Array(newArcsLength);\n\n    while (++oldIndex < oldArcsLength) {\n      if (newIndexByOldIndex[oldIndex]) {\n        newIndexByOldIndex[oldIndex] = ++newIndex;\n        newArcs[newIndex] = oldArcs[oldIndex];\n      }\n    }\n\n    for (key in oldObjects) {\n      newObjects[key] = reindexGeometry(oldObjects[key]);\n    }\n\n    return {\n      type: \"Topology\",\n      bbox: topology.bbox,\n      transform: topology.transform,\n      objects: newObjects,\n      arcs: newArcs\n    };\n  };\n\n  var filter = function (topology, filter) {\n    var oldObjects = topology.objects,\n        newObjects = {},\n        key;\n    if (filter == null) filter = filterTrue;\n\n    function filterGeometry(input) {\n      var output, arcs;\n\n      switch (input.type) {\n        case \"Polygon\":\n          {\n            arcs = filterRings(input.arcs);\n            output = arcs ? {\n              type: \"Polygon\",\n              arcs: arcs\n            } : {\n              type: null\n            };\n            break;\n          }\n\n        case \"MultiPolygon\":\n          {\n            arcs = input.arcs.map(filterRings).filter(filterIdentity);\n            output = arcs.length ? {\n              type: \"MultiPolygon\",\n              arcs: arcs\n            } : {\n              type: null\n            };\n            break;\n          }\n\n        case \"GeometryCollection\":\n          {\n            arcs = input.geometries.map(filterGeometry).filter(filterNotNull);\n            output = arcs.length ? {\n              type: \"GeometryCollection\",\n              geometries: arcs\n            } : {\n              type: null\n            };\n            break;\n          }\n\n        default:\n          return input;\n      }\n\n      if (input.id != null) output.id = input.id;\n      if (input.bbox != null) output.bbox = input.bbox;\n      if (input.properties != null) output.properties = input.properties;\n      return output;\n    }\n\n    function filterRings(arcs) {\n      return arcs.length && filterExteriorRing(arcs[0]) // if the exterior is small, ignore any holes\n      ? [arcs[0]].concat(arcs.slice(1).filter(filterInteriorRing)) : null;\n    }\n\n    function filterExteriorRing(ring) {\n      return filter(ring, false);\n    }\n\n    function filterInteriorRing(ring) {\n      return filter(ring, true);\n    }\n\n    for (key in oldObjects) {\n      newObjects[key] = filterGeometry(oldObjects[key]);\n    }\n\n    return prune({\n      type: \"Topology\",\n      bbox: topology.bbox,\n      transform: topology.transform,\n      objects: newObjects,\n      arcs: topology.arcs\n    });\n  };\n\n  function filterTrue() {\n    return true;\n  }\n\n  function filterIdentity(x) {\n    return x;\n  }\n\n  function filterNotNull(geometry) {\n    return geometry.type != null;\n  }\n\n  var filterAttached = function (topology) {\n    var ownerByArc = new Array(topology.arcs.length),\n        // arc index -> index of unique associated ring, or -1 if used by multiple rings\n    ownerIndex = 0,\n        key;\n\n    function testGeometry(o) {\n      switch (o.type) {\n        case \"GeometryCollection\":\n          o.geometries.forEach(testGeometry);\n          break;\n\n        case \"Polygon\":\n          testArcs(o.arcs);\n          break;\n\n        case \"MultiPolygon\":\n          o.arcs.forEach(testArcs);\n          break;\n      }\n    }\n\n    function testArcs(arcs) {\n      for (var i = 0, n = arcs.length; i < n; ++i, ++ownerIndex) {\n        for (var ring = arcs[i], j = 0, m = ring.length; j < m; ++j) {\n          var arc = ring[j];\n          if (arc < 0) arc = ~arc;\n          var owner = ownerByArc[arc];\n          if (owner == null) ownerByArc[arc] = ownerIndex;else if (owner !== ownerIndex) ownerByArc[arc] = -1;\n        }\n      }\n    }\n\n    for (key in topology.objects) {\n      testGeometry(topology.objects[key]);\n    }\n\n    return function (ring) {\n      for (var j = 0, m = ring.length, arc; j < m; ++j) {\n        if (ownerByArc[(arc = ring[j]) < 0 ? ~arc : arc] === -1) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n  };\n\n  function planarTriangleArea(triangle) {\n    var a = triangle[0],\n        b = triangle[1],\n        c = triangle[2];\n    return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1])) / 2;\n  }\n\n  function planarRingArea$1(ring) {\n    var i = -1,\n        n = ring.length,\n        a,\n        b = ring[n - 1],\n        area = 0;\n\n    while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n\n    return Math.abs(area) / 2;\n  }\n\n  var filterWeight = function (topology, minWeight, weight) {\n    minWeight = minWeight == null ? Number.MIN_VALUE : +minWeight;\n    if (weight == null) weight = planarRingArea$1;\n    return function (ring, interior) {\n      return weight(feature(topology, {\n        type: \"Polygon\",\n        arcs: [ring]\n      }).geometry.coordinates[0], interior) >= minWeight;\n    };\n  };\n\n  var filterAttachedWeight = function (topology, minWeight, weight) {\n    var a = filterAttached(topology),\n        w = filterWeight(topology, minWeight, weight);\n    return function (ring, interior) {\n      return a(ring, interior) || w(ring, interior);\n    };\n  };\n\n  function compare(a, b) {\n    return a[1][2] - b[1][2];\n  }\n\n  var newHeap = function () {\n    var heap = {},\n        array = [],\n        size = 0;\n\n    heap.push = function (object) {\n      up(array[object._ = size] = object, size++);\n      return size;\n    };\n\n    heap.pop = function () {\n      if (size <= 0) return;\n      var removed = array[0],\n          object;\n      if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);\n      return removed;\n    };\n\n    heap.remove = function (removed) {\n      var i = removed._,\n          object;\n      if (array[i] !== removed) return; // invalid request\n\n      if (i !== --size) object = array[size], (compare(object, removed) < 0 ? up : down)(array[object._ = i] = object, i);\n      return i;\n    };\n\n    function up(object, i) {\n      while (i > 0) {\n        var j = (i + 1 >> 1) - 1,\n            parent = array[j];\n        if (compare(object, parent) >= 0) break;\n        array[parent._ = i] = parent;\n        array[object._ = i = j] = object;\n      }\n    }\n\n    function down(object, i) {\n      while (true) {\n        var r = i + 1 << 1,\n            l = r - 1,\n            j = i,\n            child = array[j];\n        if (l < size && compare(array[l], child) < 0) child = array[j = l];\n        if (r < size && compare(array[r], child) < 0) child = array[j = r];\n        if (j === i) break;\n        array[child._ = i] = child;\n        array[object._ = i = j] = object;\n      }\n    }\n\n    return heap;\n  };\n\n  function copy(point) {\n    return [point[0], point[1], 0];\n  }\n\n  var presimplify = function (topology, weight) {\n    var point = topology.transform ? transform(topology.transform) : copy,\n        heap = newHeap();\n    if (weight == null) weight = planarTriangleArea;\n    var arcs = topology.arcs.map(function (arc) {\n      var triangles = [],\n          maxWeight = 0,\n          triangle,\n          i,\n          n;\n      arc = arc.map(point);\n\n      for (i = 1, n = arc.length - 1; i < n; ++i) {\n        triangle = [arc[i - 1], arc[i], arc[i + 1]];\n        triangle[1][2] = weight(triangle);\n        triangles.push(triangle);\n        heap.push(triangle);\n      } // Always keep the arc endpoints!\n\n\n      arc[0][2] = arc[n][2] = Infinity;\n\n      for (i = 0, n = triangles.length; i < n; ++i) {\n        triangle = triangles[i];\n        triangle.previous = triangles[i - 1];\n        triangle.next = triangles[i + 1];\n      }\n\n      while (triangle = heap.pop()) {\n        var previous = triangle.previous,\n            next = triangle.next; // If the weight of the current point is less than that of the previous\n        // point to be eliminated, use the latter’s weight instead. This ensures\n        // that the current point cannot be eliminated without eliminating\n        // previously- eliminated points.\n\n        if (triangle[1][2] < maxWeight) triangle[1][2] = maxWeight;else maxWeight = triangle[1][2];\n\n        if (previous) {\n          previous.next = next;\n          previous[2] = triangle[2];\n          update(previous);\n        }\n\n        if (next) {\n          next.previous = previous;\n          next[0] = triangle[0];\n          update(next);\n        }\n      }\n\n      return arc;\n    });\n\n    function update(triangle) {\n      heap.remove(triangle);\n      triangle[1][2] = weight(triangle);\n      heap.push(triangle);\n    }\n\n    return {\n      type: \"Topology\",\n      bbox: topology.bbox,\n      objects: topology.objects,\n      arcs: arcs\n    };\n  };\n\n  var quantile = function (topology, p) {\n    var array = [];\n    topology.arcs.forEach(function (arc) {\n      arc.forEach(function (point) {\n        if (isFinite(point[2])) {\n          // Ignore endpoints, whose weight is Infinity.\n          array.push(point[2]);\n        }\n      });\n    });\n    return array.length && quantile$1(array.sort(descending), p);\n  };\n\n  function quantile$1(array, p) {\n    if (!(n = array.length)) return;\n    if ((p = +p) <= 0 || n < 2) return array[0];\n    if (p >= 1) return array[n - 1];\n    var n,\n        h = (n - 1) * p,\n        i = Math.floor(h),\n        a = array[i],\n        b = array[i + 1];\n    return a + (b - a) * (h - i);\n  }\n\n  function descending(a, b) {\n    return b - a;\n  }\n\n  var simplify = function (topology, minWeight) {\n    minWeight = minWeight == null ? Number.MIN_VALUE : +minWeight; // Remove points whose weight is less than the minimum weight.\n\n    var arcs = topology.arcs.map(function (input) {\n      var i = -1,\n          j = 0,\n          n = input.length,\n          output = new Array(n),\n          // pessimistic\n      point;\n\n      while (++i < n) {\n        if ((point = input[i])[2] >= minWeight) {\n          output[j++] = [point[0], point[1]];\n        }\n      }\n\n      output.length = j;\n      return output;\n    });\n    return {\n      type: \"Topology\",\n      transform: topology.transform,\n      bbox: topology.bbox,\n      objects: topology.objects,\n      arcs: arcs\n    };\n  };\n\n  var pi = Math.PI;\n  var tau = 2 * pi;\n  var quarterPi = pi / 4;\n  var radians = pi / 180;\n  var abs = Math.abs;\n  var atan2 = Math.atan2;\n  var cos = Math.cos;\n  var sin = Math.sin;\n\n  function halfArea(ring, closed) {\n    var i = 0,\n        n = ring.length,\n        sum = 0,\n        point = ring[closed ? i++ : n - 1],\n        lambda0,\n        lambda1 = point[0] * radians,\n        phi1 = point[1] * radians / 2 + quarterPi,\n        cosPhi0,\n        cosPhi1 = cos(phi1),\n        sinPhi0,\n        sinPhi1 = sin(phi1);\n\n    for (; i < n; ++i) {\n      point = ring[i];\n      lambda0 = lambda1, lambda1 = point[0] * radians;\n      phi1 = point[1] * radians / 2 + quarterPi;\n      cosPhi0 = cosPhi1, cosPhi1 = cos(phi1);\n      sinPhi0 = sinPhi1, sinPhi1 = sin(phi1); // Spherical excess E for a spherical triangle with vertices: south pole,\n      // previous point, current point.  Uses a formula derived from Cagnoli’s\n      // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n      // See https://github.com/d3/d3-geo/blob/master/README.md#geoArea\n\n      var dLambda = lambda1 - lambda0,\n          sdLambda = dLambda >= 0 ? 1 : -1,\n          adLambda = sdLambda * dLambda,\n          k = sinPhi0 * sinPhi1,\n          u = cosPhi0 * cosPhi1 + k * cos(adLambda),\n          v = k * sdLambda * sin(adLambda);\n      sum += atan2(v, u);\n    }\n\n    return sum;\n  }\n\n  function sphericalRingArea(ring, interior) {\n    var sum = halfArea(ring, true);\n    if (interior) sum *= -1;\n    return (sum < 0 ? tau + sum : sum) * 2;\n  }\n\n  function sphericalTriangleArea(t) {\n    return abs(halfArea(t, false)) * 2;\n  }\n\n  exports.bbox = bbox;\n  exports.feature = feature;\n  exports.mesh = mesh;\n  exports.meshArcs = meshArcs;\n  exports.merge = merge;\n  exports.mergeArcs = mergeArcs;\n  exports.neighbors = neighbors;\n  exports.quantize = quantize;\n  exports.transform = transform;\n  exports.untransform = untransform;\n  exports.topology = topology;\n  exports.filter = filter;\n  exports.filterAttached = filterAttached;\n  exports.filterAttachedWeight = filterAttachedWeight;\n  exports.filterWeight = filterWeight;\n  exports.planarRingArea = planarRingArea$1;\n  exports.planarTriangleArea = planarTriangleArea;\n  exports.presimplify = presimplify;\n  exports.quantile = quantile;\n  exports.simplify = simplify;\n  exports.sphericalRingArea = sphericalRingArea;\n  exports.sphericalTriangleArea = sphericalTriangleArea;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["/Users/panqp/Documents/React/hw4/node_modules/topojson/dist/topojson.js"],"names":["global","factory","exports","module","define","amd","topojson","identity","x","transform","x0","y0","kx","scale","ky","dx","translate","dy","input","i","j","n","length","output","Array","bbox","topology","t","key","Infinity","x1","y1","bboxPoint","p","bboxGeometry","o","type","geometries","forEach","coordinates","arcs","arc","objects","reverse","array","feature","features","map","feature$1","id","properties","geometry","object","transformPoint","points","pop","a","k","push","point","line","ring","polygon","stitch","stitchedArcs","fragmentByStart","fragmentByEnd","fragments","emptyIndex","e","ends","start","end","f","g","fg","concat","unshift","gf","p0","p1","dp","flush","mesh","meshArcs","apply","arguments","object$$1","filter","extractArcs","geomsByArc","geom","extract0","extract1","extract2","extract3","geoms","planarRingArea","b","area","Math","abs","merge","mergeArcs","polygonsByArc","polygons","groups","extract","_","group","neighbors","ki","bisect","lo","hi","mid","indexesByArc","geometryType","LineString","MultiLineString","Polygon","MultiPolygon","indexes","m","ij","ik","splice","untransform","round","quantize","Error","floor","box","inputs","outputs","quantizePoint","quantizeGeometry","quantizeArc","bounds","boundGeometry","boundGeometryType","hasOwnProperty","GeometryCollection","Point","boundPoint","MultiPoint","boundLine","boundMultiLine","y","undefined","hashset","size","hash","equal","empty","store","max","ceil","log","LN2","mask","add","value","index","match","collisions","has","values","hashmap","keyType","keyEmpty","valueType","keystore","valstore","set","matchKey","maybeSet","get","missingValue","keys","equalPoint","pointA","pointB","buffer","ArrayBuffer","uints","Uint32Array","hashPoint","join","lines","rings","visitedByIndex","Int32Array","leftByIndex","rightByIndex","junctionByIndex","Int8Array","junctionCount","previousIndex","currentIndex","nextIndex","lineStart","lineEnd","sequence","ringStart","ringEnd","leftIndex","rightIndex","indexByPoint","hashIndex","equalIndex","junctionByPoint","cut","junctions","next","lineMid","ringMid","ringFixed","rotateArray","offset","reverse$1","dedup","arcCount","arcsByEnd","dedupLine","dedupRing","startPoint","endPoint","startArcs","startArc","endArcs","endArc","equalLine","reverseEqualLine","equalRing","reverseEqualRing","findMinimumOffset","arcA","arcB","ia","ib","ja","jb","ka","kb","minimum","minimumPoint","delta","extractGeometry","extractGeometryType","extractLine","extractRing","extractMultiRing","geomifyObject","geomifyFeatureCollection","geomifyFeature","geomifyGeometry","prequantize","quantizePoints","pi","px","py","quantizeLine","quantizeRing","quantizePolygon","quantizeGeometryType","quantization","indexByArc","hashArc","equalArc","slice","indexGeometry","geometry$$1","indexGeometryType","indexArcs","indexMultiArcs","prune","oldObjects","newObjects","oldArcs","oldArcsLength","oldIndex","newIndexByOldIndex","newArcsLength","newArcs","newIndex","scanGeometry","scanArcs","scanMultiArcs","scanArc","reindexGeometry","reindexArcs","reindexMultiArcs","reindexArc","filterTrue","filterGeometry","filterRings","filterIdentity","filterNotNull","filterExteriorRing","filterInteriorRing","filterAttached","ownerByArc","ownerIndex","testGeometry","testArcs","owner","planarTriangleArea","triangle","c","planarRingArea$1","filterWeight","minWeight","weight","Number","MIN_VALUE","interior","filterAttachedWeight","w","compare","newHeap","heap","up","removed","down","remove","parent","r","l","child","copy","presimplify","triangles","maxWeight","previous","update","quantile","isFinite","quantile$1","sort","descending","h","simplify","PI","tau","quarterPi","radians","atan2","cos","sin","halfArea","closed","sum","lambda0","lambda1","phi1","cosPhi0","cosPhi1","sinPhi0","sinPhi1","dLambda","sdLambda","adLambda","u","v","sphericalRingArea","sphericalTriangleArea","Object","defineProperty"],"mappings":"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","sourcesContent":["// https://github.com/topojson/topojson Version 3.0.2. Copyright 2017 Mike Bostock.\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.topojson = global.topojson || {})));\n}(this, (function (exports) { 'use strict';\n\nvar identity = function(x) {\n  return x;\n};\n\nvar transform = function(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2, n = input.length, output = new Array(n);\n    output[0] = (x0 += input[0]) * kx + dx;\n    output[1] = (y0 += input[1]) * ky + dy;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n};\n\nvar bbox = function(topology) {\n  var t = transform(topology.transform), key,\n      x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;\n\n  function bboxPoint(p) {\n    p = t(p);\n    if (p[0] < x0) x0 = p[0];\n    if (p[0] > x1) x1 = p[0];\n    if (p[1] < y0) y0 = p[1];\n    if (p[1] > y1) y1 = p[1];\n  }\n\n  function bboxGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(bboxGeometry); break;\n      case \"Point\": bboxPoint(o.coordinates); break;\n      case \"MultiPoint\": o.coordinates.forEach(bboxPoint); break;\n    }\n  }\n\n  topology.arcs.forEach(function(arc) {\n    var i = -1, n = arc.length, p;\n    while (++i < n) {\n      p = t(arc[i], i);\n      if (p[0] < x0) x0 = p[0];\n      if (p[0] > x1) x1 = p[0];\n      if (p[1] < y0) y0 = p[1];\n      if (p[1] > y1) y1 = p[1];\n    }\n  });\n\n  for (key in topology.objects) {\n    bboxGeometry(topology.objects[key]);\n  }\n\n  return [x0, y0, x1, y1];\n};\n\nvar reverse = function(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n};\n\nvar feature = function(topology, o) {\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature$1(topology, o); })}\n      : feature$1(topology, o);\n};\n\nfunction feature$1(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nfunction object(topology, o) {\n  var transformPoint = transform(topology.transform),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) points.pop();\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k], k));\n    }\n    if (i < 0) reverse(points, n);\n  }\n\n  function point(p) {\n    return transformPoint(p);\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n\nvar stitch = function(topology, arcs) {\n  var stitchedArcs = {},\n      fragmentByStart = {},\n      fragmentByEnd = {},\n      fragments = [],\n      emptyIndex = -1;\n\n  // Stitch empty arcs first, since they may be subsumed by other arcs.\n  arcs.forEach(function(i, j) {\n    var arc = topology.arcs[i < 0 ? ~i : i], t;\n    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n    }\n  });\n\n  arcs.forEach(function(i) {\n    var e = ends(i),\n        start = e[0],\n        end = e[1],\n        f, g;\n\n    if (f = fragmentByEnd[start]) {\n      delete fragmentByEnd[f.end];\n      f.push(i);\n      f.end = end;\n      if (g = fragmentByStart[end]) {\n        delete fragmentByStart[g.start];\n        var fg = g === f ? f : f.concat(g);\n        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else if (f = fragmentByStart[end]) {\n      delete fragmentByStart[f.start];\n      f.unshift(i);\n      f.start = start;\n      if (g = fragmentByEnd[start]) {\n        delete fragmentByEnd[g.end];\n        var gf = g === f ? f : g.concat(f);\n        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else {\n      f = [i];\n      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n    }\n  });\n\n  function ends(i) {\n    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });\n    else p1 = arc[arc.length - 1];\n    return i < 0 ? [p1, p0] : [p0, p1];\n  }\n\n  function flush(fragmentByEnd, fragmentByStart) {\n    for (var k in fragmentByEnd) {\n      var f = fragmentByEnd[k];\n      delete fragmentByStart[f.start];\n      delete f.start;\n      delete f.end;\n      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n      fragments.push(f);\n    }\n  }\n\n  flush(fragmentByEnd, fragmentByStart);\n  flush(fragmentByStart, fragmentByEnd);\n  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });\n\n  return fragments;\n};\n\nvar mesh = function(topology) {\n  return object(topology, meshArcs.apply(this, arguments));\n};\n\nfunction meshArcs(topology, object$$1, filter) {\n  var arcs, i, n;\n  if (arguments.length > 1) arcs = extractArcs(topology, object$$1, filter);\n  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;\n  return {type: \"MultiLineString\", arcs: stitch(topology, arcs)};\n}\n\nfunction extractArcs(topology, object$$1, filter) {\n  var arcs = [],\n      geomsByArc = [],\n      geom;\n\n  function extract0(i) {\n    var j = i < 0 ? ~i : i;\n    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});\n  }\n\n  function extract1(arcs) {\n    arcs.forEach(extract0);\n  }\n\n  function extract2(arcs) {\n    arcs.forEach(extract1);\n  }\n\n  function extract3(arcs) {\n    arcs.forEach(extract2);\n  }\n\n  function geometry(o) {\n    switch (geom = o, o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"LineString\": extract1(o.arcs); break;\n      case \"MultiLineString\": case \"Polygon\": extract2(o.arcs); break;\n      case \"MultiPolygon\": extract3(o.arcs); break;\n    }\n  }\n\n  geometry(object$$1);\n\n  geomsByArc.forEach(filter == null\n      ? function(geoms) { arcs.push(geoms[0].i); }\n      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });\n\n  return arcs;\n}\n\nfunction planarRingArea(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n  return Math.abs(area); // Note: doubled area!\n}\n\nvar merge = function(topology) {\n  return object(topology, mergeArcs.apply(this, arguments));\n};\n\nfunction mergeArcs(topology, objects) {\n  var polygonsByArc = {},\n      polygons = [],\n      groups = [];\n\n  objects.forEach(geometry);\n\n  function geometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"Polygon\": extract(o.arcs); break;\n      case \"MultiPolygon\": o.arcs.forEach(extract); break;\n    }\n  }\n\n  function extract(polygon) {\n    polygon.forEach(function(ring) {\n      ring.forEach(function(arc) {\n        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n      });\n    });\n    polygons.push(polygon);\n  }\n\n  function area(ring) {\n    return planarRingArea(object(topology, {type: \"Polygon\", arcs: [ring]}).coordinates[0]);\n  }\n\n  polygons.forEach(function(polygon) {\n    if (!polygon._) {\n      var group = [],\n          neighbors = [polygon];\n      polygon._ = 1;\n      groups.push(group);\n      while (polygon = neighbors.pop()) {\n        group.push(polygon);\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {\n              if (!polygon._) {\n                polygon._ = 1;\n                neighbors.push(polygon);\n              }\n            });\n          });\n        });\n      }\n    }\n  });\n\n  polygons.forEach(function(polygon) {\n    delete polygon._;\n  });\n\n  return {\n    type: \"MultiPolygon\",\n    arcs: groups.map(function(polygons) {\n      var arcs = [], n;\n\n      // Extract the exterior (unique) arcs.\n      polygons.forEach(function(polygon) {\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n              arcs.push(arc);\n            }\n          });\n        });\n      });\n\n      // Stitch the arcs into one or more rings.\n      arcs = stitch(topology, arcs);\n\n      // If more than one ring is returned,\n      // at most one of these rings can be the exterior;\n      // choose the one with the greatest absolute area.\n      if ((n = arcs.length) > 1) {\n        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n          if ((ki = area(arcs[i])) > k) {\n            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n          }\n        }\n      }\n\n      return arcs;\n    })\n  };\n}\n\nvar bisect = function(a, x) {\n  var lo = 0, hi = a.length;\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (a[mid] < x) lo = mid + 1;\n    else hi = mid;\n  }\n  return lo;\n};\n\nvar neighbors = function(objects) {\n  var indexesByArc = {}, // arc index -> array of object indexes\n      neighbors = objects.map(function() { return []; });\n\n  function line(arcs, i) {\n    arcs.forEach(function(a) {\n      if (a < 0) a = ~a;\n      var o = indexesByArc[a];\n      if (o) o.push(i);\n      else indexesByArc[a] = [i];\n    });\n  }\n\n  function polygon(arcs, i) {\n    arcs.forEach(function(arc) { line(arc, i); });\n  }\n\n  function geometry(o, i) {\n    if (o.type === \"GeometryCollection\") o.geometries.forEach(function(o) { geometry(o, i); });\n    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);\n  }\n\n  var geometryType = {\n    LineString: line,\n    MultiLineString: polygon,\n    Polygon: polygon,\n    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }\n  };\n\n  objects.forEach(geometry);\n\n  for (var i in indexesByArc) {\n    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {\n      for (var k = j + 1; k < m; ++k) {\n        var ij = indexes[j], ik = indexes[k], n;\n        if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);\n        if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);\n      }\n    }\n  }\n\n  return neighbors;\n};\n\nvar untransform = function(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2,\n        n = input.length,\n        output = new Array(n),\n        x1 = Math.round((input[0] - dx) / kx),\n        y1 = Math.round((input[1] - dy) / ky);\n    output[0] = x1 - x0, x0 = x1;\n    output[1] = y1 - y0, y0 = y1;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n};\n\nvar quantize = function(topology, transform) {\n  if (topology.transform) throw new Error(\"already quantized\");\n\n  if (!transform || !transform.scale) {\n    if (!((n = Math.floor(transform)) >= 2)) throw new Error(\"n must be \\u22652\");\n    box = topology.bbox || bbox(topology);\n    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;\n    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};\n  } else {\n    box = topology.bbox;\n  }\n\n  var t = untransform(transform), box, key, inputs = topology.objects, outputs = {};\n\n  function quantizePoint(point) {\n    return t(point);\n  }\n\n  function quantizeGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(quantizeGeometry)}; break;\n      case \"Point\": output = {type: \"Point\", coordinates: quantizePoint(input.coordinates)}; break;\n      case \"MultiPoint\": output = {type: \"MultiPoint\", coordinates: input.coordinates.map(quantizePoint)}; break;\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function quantizeArc(input) {\n    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic\n    output[0] = t(input[0], 0);\n    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points\n    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points\n    output.length = j;\n    return output;\n  }\n\n  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);\n\n  return {\n    type: \"Topology\",\n    bbox: box,\n    transform: transform,\n    objects: outputs,\n    arcs: topology.arcs.map(quantizeArc)\n  };\n};\n\n// Computes the bounding box of the specified hash of GeoJSON objects.\nvar bounds = function(objects) {\n  var x0 = Infinity,\n      y0 = Infinity,\n      x1 = -Infinity,\n      y1 = -Infinity;\n\n  function boundGeometry(geometry) {\n    if (geometry != null && boundGeometryType.hasOwnProperty(geometry.type)) boundGeometryType[geometry.type](geometry);\n  }\n\n  var boundGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(boundGeometry); },\n    Point: function(o) { boundPoint(o.coordinates); },\n    MultiPoint: function(o) { o.coordinates.forEach(boundPoint); },\n    LineString: function(o) { boundLine(o.arcs); },\n    MultiLineString: function(o) { o.arcs.forEach(boundLine); },\n    Polygon: function(o) { o.arcs.forEach(boundLine); },\n    MultiPolygon: function(o) { o.arcs.forEach(boundMultiLine); }\n  };\n\n  function boundPoint(coordinates) {\n    var x = coordinates[0],\n        y = coordinates[1];\n    if (x < x0) x0 = x;\n    if (x > x1) x1 = x;\n    if (y < y0) y0 = y;\n    if (y > y1) y1 = y;\n  }\n\n  function boundLine(coordinates) {\n    coordinates.forEach(boundPoint);\n  }\n\n  function boundMultiLine(coordinates) {\n    coordinates.forEach(boundLine);\n  }\n\n  for (var key in objects) {\n    boundGeometry(objects[key]);\n  }\n\n  return x1 >= x0 && y1 >= y0 ? [x0, y0, x1, y1] : undefined;\n};\n\nvar hashset = function(size, hash, equal, type, empty) {\n  if (arguments.length === 3) {\n    type = Array;\n    empty = null;\n  }\n\n  var store = new type(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),\n      mask = size - 1;\n\n  for (var i = 0; i < size; ++i) {\n    store[i] = empty;\n  }\n\n  function add(value) {\n    var index = hash(value) & mask,\n        match = store[index],\n        collisions = 0;\n    while (match != empty) {\n      if (equal(match, value)) return true;\n      if (++collisions >= size) throw new Error(\"full hashset\");\n      match = store[index = (index + 1) & mask];\n    }\n    store[index] = value;\n    return true;\n  }\n\n  function has(value) {\n    var index = hash(value) & mask,\n        match = store[index],\n        collisions = 0;\n    while (match != empty) {\n      if (equal(match, value)) return true;\n      if (++collisions >= size) break;\n      match = store[index = (index + 1) & mask];\n    }\n    return false;\n  }\n\n  function values() {\n    var values = [];\n    for (var i = 0, n = store.length; i < n; ++i) {\n      var match = store[i];\n      if (match != empty) values.push(match);\n    }\n    return values;\n  }\n\n  return {\n    add: add,\n    has: has,\n    values: values\n  };\n};\n\nvar hashmap = function(size, hash, equal, keyType, keyEmpty, valueType) {\n  if (arguments.length === 3) {\n    keyType = valueType = Array;\n    keyEmpty = null;\n  }\n\n  var keystore = new keyType(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),\n      valstore = new valueType(size),\n      mask = size - 1;\n\n  for (var i = 0; i < size; ++i) {\n    keystore[i] = keyEmpty;\n  }\n\n  function set(key, value) {\n    var index = hash(key) & mask,\n        matchKey = keystore[index],\n        collisions = 0;\n    while (matchKey != keyEmpty) {\n      if (equal(matchKey, key)) return valstore[index] = value;\n      if (++collisions >= size) throw new Error(\"full hashmap\");\n      matchKey = keystore[index = (index + 1) & mask];\n    }\n    keystore[index] = key;\n    valstore[index] = value;\n    return value;\n  }\n\n  function maybeSet(key, value) {\n    var index = hash(key) & mask,\n        matchKey = keystore[index],\n        collisions = 0;\n    while (matchKey != keyEmpty) {\n      if (equal(matchKey, key)) return valstore[index];\n      if (++collisions >= size) throw new Error(\"full hashmap\");\n      matchKey = keystore[index = (index + 1) & mask];\n    }\n    keystore[index] = key;\n    valstore[index] = value;\n    return value;\n  }\n\n  function get(key, missingValue) {\n    var index = hash(key) & mask,\n        matchKey = keystore[index],\n        collisions = 0;\n    while (matchKey != keyEmpty) {\n      if (equal(matchKey, key)) return valstore[index];\n      if (++collisions >= size) break;\n      matchKey = keystore[index = (index + 1) & mask];\n    }\n    return missingValue;\n  }\n\n  function keys() {\n    var keys = [];\n    for (var i = 0, n = keystore.length; i < n; ++i) {\n      var matchKey = keystore[i];\n      if (matchKey != keyEmpty) keys.push(matchKey);\n    }\n    return keys;\n  }\n\n  return {\n    set: set,\n    maybeSet: maybeSet, // set if unset\n    get: get,\n    keys: keys\n  };\n};\n\nvar equalPoint = function(pointA, pointB) {\n  return pointA[0] === pointB[0] && pointA[1] === pointB[1];\n};\n\n// TODO if quantized, use simpler Int32 hashing?\n\nvar buffer = new ArrayBuffer(16);\nvar uints = new Uint32Array(buffer);\n\nvar hashPoint = function(point) {\n  var hash = uints[0] ^ uints[1];\n  hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];\n  return hash & 0x7fffffff;\n};\n\n// Given an extracted (pre-)topology, identifies all of the junctions. These are\n// the points at which arcs (lines or rings) will need to be cut so that each\n// arc is represented uniquely.\n//\n// A junction is a point where at least one arc deviates from another arc going\n// through the same point. For example, consider the point B. If there is a arc\n// through ABC and another arc through CBA, then B is not a junction because in\n// both cases the adjacent point pairs are {A,C}. However, if there is an\n// additional arc ABD, then {A,D} != {A,C}, and thus B becomes a junction.\n//\n// For a closed ring ABCA, the first point A’s adjacent points are the second\n// and last point {B,C}. For a line, the first and last point are always\n// considered junctions, even if the line is closed; this ensures that a closed\n// line is never rotated.\nvar join = function(topology) {\n  var coordinates = topology.coordinates,\n      lines = topology.lines,\n      rings = topology.rings,\n      indexes = index(),\n      visitedByIndex = new Int32Array(coordinates.length),\n      leftByIndex = new Int32Array(coordinates.length),\n      rightByIndex = new Int32Array(coordinates.length),\n      junctionByIndex = new Int8Array(coordinates.length),\n      junctionCount = 0, // upper bound on number of junctions\n      i, n,\n      previousIndex,\n      currentIndex,\n      nextIndex;\n\n  for (i = 0, n = coordinates.length; i < n; ++i) {\n    visitedByIndex[i] = leftByIndex[i] = rightByIndex[i] = -1;\n  }\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    var line = lines[i],\n        lineStart = line[0],\n        lineEnd = line[1];\n    currentIndex = indexes[lineStart];\n    nextIndex = indexes[++lineStart];\n    ++junctionCount, junctionByIndex[currentIndex] = 1; // start\n    while (++lineStart <= lineEnd) {\n      sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[lineStart]);\n    }\n    ++junctionCount, junctionByIndex[nextIndex] = 1; // end\n  }\n\n  for (i = 0, n = coordinates.length; i < n; ++i) {\n    visitedByIndex[i] = -1;\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    var ring = rings[i],\n        ringStart = ring[0] + 1,\n        ringEnd = ring[1];\n    previousIndex = indexes[ringEnd - 1];\n    currentIndex = indexes[ringStart - 1];\n    nextIndex = indexes[ringStart];\n    sequence(i, previousIndex, currentIndex, nextIndex);\n    while (++ringStart <= ringEnd) {\n      sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[ringStart]);\n    }\n  }\n\n  function sequence(i, previousIndex, currentIndex, nextIndex) {\n    if (visitedByIndex[currentIndex] === i) return; // ignore self-intersection\n    visitedByIndex[currentIndex] = i;\n    var leftIndex = leftByIndex[currentIndex];\n    if (leftIndex >= 0) {\n      var rightIndex = rightByIndex[currentIndex];\n      if ((leftIndex !== previousIndex || rightIndex !== nextIndex)\n        && (leftIndex !== nextIndex || rightIndex !== previousIndex)) {\n        ++junctionCount, junctionByIndex[currentIndex] = 1;\n      }\n    } else {\n      leftByIndex[currentIndex] = previousIndex;\n      rightByIndex[currentIndex] = nextIndex;\n    }\n  }\n\n  function index() {\n    var indexByPoint = hashmap(coordinates.length * 1.4, hashIndex, equalIndex, Int32Array, -1, Int32Array),\n        indexes = new Int32Array(coordinates.length);\n\n    for (var i = 0, n = coordinates.length; i < n; ++i) {\n      indexes[i] = indexByPoint.maybeSet(i, i);\n    }\n\n    return indexes;\n  }\n\n  function hashIndex(i) {\n    return hashPoint(coordinates[i]);\n  }\n\n  function equalIndex(i, j) {\n    return equalPoint(coordinates[i], coordinates[j]);\n  }\n\n  visitedByIndex = leftByIndex = rightByIndex = null;\n\n  var junctionByPoint = hashset(junctionCount * 1.4, hashPoint, equalPoint), j;\n\n  // Convert back to a standard hashset by point for caller convenience.\n  for (i = 0, n = coordinates.length; i < n; ++i) {\n    if (junctionByIndex[j = indexes[i]]) {\n      junctionByPoint.add(coordinates[j]);\n    }\n  }\n\n  return junctionByPoint;\n};\n\n// Given an extracted (pre-)topology, cuts (or rotates) arcs so that all shared\n// point sequences are identified. The topology can then be subsequently deduped\n// to remove exact duplicate arcs.\nvar cut = function(topology) {\n  var junctions = join(topology),\n      coordinates = topology.coordinates,\n      lines = topology.lines,\n      rings = topology.rings,\n      next,\n      i, n;\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    var line = lines[i],\n        lineMid = line[0],\n        lineEnd = line[1];\n    while (++lineMid < lineEnd) {\n      if (junctions.has(coordinates[lineMid])) {\n        next = {0: lineMid, 1: line[1]};\n        line[1] = lineMid;\n        line = line.next = next;\n      }\n    }\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    var ring = rings[i],\n        ringStart = ring[0],\n        ringMid = ringStart,\n        ringEnd = ring[1],\n        ringFixed = junctions.has(coordinates[ringStart]);\n    while (++ringMid < ringEnd) {\n      if (junctions.has(coordinates[ringMid])) {\n        if (ringFixed) {\n          next = {0: ringMid, 1: ring[1]};\n          ring[1] = ringMid;\n          ring = ring.next = next;\n        } else { // For the first junction, we can rotate rather than cut.\n          rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);\n          coordinates[ringEnd] = coordinates[ringStart];\n          ringFixed = true;\n          ringMid = ringStart; // restart; we may have skipped junctions\n        }\n      }\n    }\n  }\n\n  return topology;\n};\n\nfunction rotateArray(array, start, end, offset) {\n  reverse$1(array, start, end);\n  reverse$1(array, start, start + offset);\n  reverse$1(array, start + offset, end);\n}\n\nfunction reverse$1(array, start, end) {\n  for (var mid = start + ((end-- - start) >> 1), t; start < mid; ++start, --end) {\n    t = array[start], array[start] = array[end], array[end] = t;\n  }\n}\n\n// Given a cut topology, combines duplicate arcs.\nvar dedup = function(topology) {\n  var coordinates = topology.coordinates,\n      lines = topology.lines, line,\n      rings = topology.rings, ring,\n      arcCount = lines.length + rings.length,\n      i, n;\n\n  delete topology.lines;\n  delete topology.rings;\n\n  // Count the number of (non-unique) arcs to initialize the hashmap safely.\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i]; while (line = line.next) ++arcCount;\n  }\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i]; while (ring = ring.next) ++arcCount;\n  }\n\n  var arcsByEnd = hashmap(arcCount * 2 * 1.4, hashPoint, equalPoint),\n      arcs = topology.arcs = [];\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i];\n    do {\n      dedupLine(line);\n    } while (line = line.next);\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i];\n    if (ring.next) { // arc is no longer closed\n      do {\n        dedupLine(ring);\n      } while (ring = ring.next);\n    } else {\n      dedupRing(ring);\n    }\n  }\n\n  function dedupLine(arc) {\n    var startPoint,\n        endPoint,\n        startArcs, startArc,\n        endArcs, endArc,\n        i, n;\n\n    // Does this arc match an existing arc in order?\n    if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {\n      for (i = 0, n = startArcs.length; i < n; ++i) {\n        startArc = startArcs[i];\n        if (equalLine(startArc, arc)) {\n          arc[0] = startArc[0];\n          arc[1] = startArc[1];\n          return;\n        }\n      }\n    }\n\n    // Does this arc match an existing arc in reverse order?\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (reverseEqualLine(endArc, arc)) {\n          arc[1] = endArc[0];\n          arc[0] = endArc[1];\n          return;\n        }\n      }\n    }\n\n    if (startArcs) startArcs.push(arc); else arcsByEnd.set(startPoint, [arc]);\n    if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function dedupRing(arc) {\n    var endPoint,\n        endArcs,\n        endArc,\n        i, n;\n\n    // Does this arc match an existing line in order, or reverse order?\n    // Rings are closed, so their start point and end point is the same.\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n\n    // Otherwise, does this arc match an existing ring in order, or reverse order?\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n\n    if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function equalLine(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n    for (; ia <= ja; ++ia, ++ib) if (!equalPoint(coordinates[ia], coordinates[ib])) return false;\n    return true;\n  }\n\n  function reverseEqualLine(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n    for (; ia <= ja; ++ia, --jb) if (!equalPoint(coordinates[ia], coordinates[jb])) return false;\n    return true;\n  }\n\n  function equalRing(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = findMinimumOffset(arcB);\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[ib + (i + kb) % n])) return false;\n    }\n    return true;\n  }\n\n  function reverseEqualRing(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = n - findMinimumOffset(arcB);\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[jb - (i + kb) % n])) return false;\n    }\n    return true;\n  }\n\n  // Rings are rotated to a consistent, but arbitrary, start point.\n  // This is necessary to detect when a ring and a rotated copy are dupes.\n  function findMinimumOffset(arc) {\n    var start = arc[0],\n        end = arc[1],\n        mid = start,\n        minimum = mid,\n        minimumPoint = coordinates[mid];\n    while (++mid < end) {\n      var point = coordinates[mid];\n      if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {\n        minimum = mid;\n        minimumPoint = point;\n      }\n    }\n    return minimum - start;\n  }\n\n  return topology;\n};\n\n// Given an array of arcs in absolute (but already quantized!) coordinates,\n// converts to fixed-point delta encoding.\n// This is a destructive operation that modifies the given arcs!\nvar delta = function(arcs) {\n  var i = -1,\n      n = arcs.length;\n\n  while (++i < n) {\n    var arc = arcs[i],\n        j = 0,\n        k = 1,\n        m = arc.length,\n        point = arc[0],\n        x0 = point[0],\n        y0 = point[1],\n        x1,\n        y1;\n\n    while (++j < m) {\n      point = arc[j], x1 = point[0], y1 = point[1];\n      if (x1 !== x0 || y1 !== y0) arc[k++] = [x1 - x0, y1 - y0], x0 = x1, y0 = y1;\n    }\n\n    if (k === 1) arc[k++] = [0, 0]; // Each arc must be an array of two or more positions.\n\n    arc.length = k;\n  }\n\n  return arcs;\n};\n\n// Extracts the lines and rings from the specified hash of geometry objects.\n//\n// Returns an object with three properties:\n//\n// * coordinates - shared buffer of [x, y] coordinates\n// * lines - lines extracted from the hash, of the form [start, end]\n// * rings - rings extracted from the hash, of the form [start, end]\n//\n// For each ring or line, start and end represent inclusive indexes into the\n// coordinates buffer. For rings (and closed lines), coordinates[start] equals\n// coordinates[end].\n//\n// For each line or polygon geometry in the input hash, including nested\n// geometries as in geometry collections, the `coordinates` array is replaced\n// with an equivalent `arcs` array that, for each line (for line string\n// geometries) or ring (for polygon geometries), points to one of the above\n// lines or rings.\nvar extract = function(objects) {\n  var index = -1,\n      lines = [],\n      rings = [],\n      coordinates = [];\n\n  function extractGeometry(geometry) {\n    if (geometry && extractGeometryType.hasOwnProperty(geometry.type)) extractGeometryType[geometry.type](geometry);\n  }\n\n  var extractGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(extractGeometry); },\n    LineString: function(o) { o.arcs = extractLine(o.arcs); },\n    MultiLineString: function(o) { o.arcs = o.arcs.map(extractLine); },\n    Polygon: function(o) { o.arcs = o.arcs.map(extractRing); },\n    MultiPolygon: function(o) { o.arcs = o.arcs.map(extractMultiRing); }\n  };\n\n  function extractLine(line) {\n    for (var i = 0, n = line.length; i < n; ++i) coordinates[++index] = line[i];\n    var arc = {0: index - n + 1, 1: index};\n    lines.push(arc);\n    return arc;\n  }\n\n  function extractRing(ring) {\n    for (var i = 0, n = ring.length; i < n; ++i) coordinates[++index] = ring[i];\n    var arc = {0: index - n + 1, 1: index};\n    rings.push(arc);\n    return arc;\n  }\n\n  function extractMultiRing(rings) {\n    return rings.map(extractRing);\n  }\n\n  for (var key in objects) {\n    extractGeometry(objects[key]);\n  }\n\n  return {\n    type: \"Topology\",\n    coordinates: coordinates,\n    lines: lines,\n    rings: rings,\n    objects: objects\n  };\n};\n\n// Given a hash of GeoJSON objects, returns a hash of GeoJSON geometry objects.\n// Any null input geometry objects are represented as {type: null} in the output.\n// Any feature.{id,properties,bbox} are transferred to the output geometry object.\n// Each output geometry object is a shallow copy of the input (e.g., properties, coordinates)!\nvar geometry = function(inputs) {\n  var outputs = {}, key;\n  for (key in inputs) outputs[key] = geomifyObject(inputs[key]);\n  return outputs;\n};\n\nfunction geomifyObject(input) {\n  return input == null ? {type: null}\n      : (input.type === \"FeatureCollection\" ? geomifyFeatureCollection\n      : input.type === \"Feature\" ? geomifyFeature\n      : geomifyGeometry)(input);\n}\n\nfunction geomifyFeatureCollection(input) {\n  var output = {type: \"GeometryCollection\", geometries: input.features.map(geomifyFeature)};\n  if (input.bbox != null) output.bbox = input.bbox;\n  return output;\n}\n\nfunction geomifyFeature(input) {\n  var output = geomifyGeometry(input.geometry), key; // eslint-disable-line no-unused-vars\n  if (input.id != null) output.id = input.id;\n  if (input.bbox != null) output.bbox = input.bbox;\n  for (key in input.properties) { output.properties = input.properties; break; }\n  return output;\n}\n\nfunction geomifyGeometry(input) {\n  if (input == null) return {type: null};\n  var output = input.type === \"GeometryCollection\" ? {type: \"GeometryCollection\", geometries: input.geometries.map(geomifyGeometry)}\n      : input.type === \"Point\" || input.type === \"MultiPoint\" ? {type: input.type, coordinates: input.coordinates}\n      : {type: input.type, arcs: input.coordinates}; // TODO Check for unknown types?\n  if (input.bbox != null) output.bbox = input.bbox;\n  return output;\n}\n\nvar prequantize = function(objects, bbox, n) {\n  var x0 = bbox[0],\n      y0 = bbox[1],\n      x1 = bbox[2],\n      y1 = bbox[3],\n      kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1,\n      ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;\n\n  function quantizePoint(input) {\n    return [Math.round((input[0] - x0) * kx), Math.round((input[1] - y0) * ky)];\n  }\n\n  function quantizePoints(input, m) {\n    var i = -1,\n        j = 0,\n        n = input.length,\n        output = new Array(n), // pessimistic\n        pi,\n        px,\n        py,\n        x,\n        y;\n\n    while (++i < n) {\n      pi = input[i];\n      x = Math.round((pi[0] - x0) * kx);\n      y = Math.round((pi[1] - y0) * ky);\n      if (x !== px || y !== py) output[j++] = [px = x, py = y]; // non-coincident points\n    }\n\n    output.length = j;\n    while (j < m) j = output.push([output[0][0], output[0][1]]);\n    return output;\n  }\n\n  function quantizeLine(input) {\n    return quantizePoints(input, 2);\n  }\n\n  function quantizeRing(input) {\n    return quantizePoints(input, 4);\n  }\n\n  function quantizePolygon(input) {\n    return input.map(quantizeRing);\n  }\n\n  function quantizeGeometry(o) {\n    if (o != null && quantizeGeometryType.hasOwnProperty(o.type)) quantizeGeometryType[o.type](o);\n  }\n\n  var quantizeGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(quantizeGeometry); },\n    Point: function(o) { o.coordinates = quantizePoint(o.coordinates); },\n    MultiPoint: function(o) { o.coordinates = o.coordinates.map(quantizePoint); },\n    LineString: function(o) { o.arcs = quantizeLine(o.arcs); },\n    MultiLineString: function(o) { o.arcs = o.arcs.map(quantizeLine); },\n    Polygon: function(o) { o.arcs = quantizePolygon(o.arcs); },\n    MultiPolygon: function(o) { o.arcs = o.arcs.map(quantizePolygon); }\n  };\n\n  for (var key in objects) {\n    quantizeGeometry(objects[key]);\n  }\n\n  return {\n    scale: [1 / kx, 1 / ky],\n    translate: [x0, y0]\n  };\n};\n\n// Constructs the TopoJSON Topology for the specified hash of features.\n// Each object in the specified hash must be a GeoJSON object,\n// meaning FeatureCollection, a Feature or a geometry object.\nvar topology = function(objects, quantization) {\n  var bbox = bounds(objects = geometry(objects)),\n      transform = quantization > 0 && bbox && prequantize(objects, bbox, quantization),\n      topology = dedup(cut(extract(objects))),\n      coordinates = topology.coordinates,\n      indexByArc = hashmap(topology.arcs.length * 1.4, hashArc, equalArc);\n\n  objects = topology.objects; // for garbage collection\n  topology.bbox = bbox;\n  topology.arcs = topology.arcs.map(function(arc, i) {\n    indexByArc.set(arc, i);\n    return coordinates.slice(arc[0], arc[1] + 1);\n  });\n\n  delete topology.coordinates;\n  coordinates = null;\n\n  function indexGeometry(geometry$$1) {\n    if (geometry$$1 && indexGeometryType.hasOwnProperty(geometry$$1.type)) indexGeometryType[geometry$$1.type](geometry$$1);\n  }\n\n  var indexGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(indexGeometry); },\n    LineString: function(o) { o.arcs = indexArcs(o.arcs); },\n    MultiLineString: function(o) { o.arcs = o.arcs.map(indexArcs); },\n    Polygon: function(o) { o.arcs = o.arcs.map(indexArcs); },\n    MultiPolygon: function(o) { o.arcs = o.arcs.map(indexMultiArcs); }\n  };\n\n  function indexArcs(arc) {\n    var indexes = [];\n    do {\n      var index = indexByArc.get(arc);\n      indexes.push(arc[0] < arc[1] ? index : ~index);\n    } while (arc = arc.next);\n    return indexes;\n  }\n\n  function indexMultiArcs(arcs) {\n    return arcs.map(indexArcs);\n  }\n\n  for (var key in objects) {\n    indexGeometry(objects[key]);\n  }\n\n  if (transform) {\n    topology.transform = transform;\n    topology.arcs = delta(topology.arcs);\n  }\n\n  return topology;\n};\n\nfunction hashArc(arc) {\n  var i = arc[0], j = arc[1], t;\n  if (j < i) t = i, i = j, j = t;\n  return i + 31 * j;\n}\n\nfunction equalArc(arcA, arcB) {\n  var ia = arcA[0], ja = arcA[1],\n      ib = arcB[0], jb = arcB[1], t;\n  if (ja < ia) t = ia, ia = ja, ja = t;\n  if (jb < ib) t = ib, ib = jb, jb = t;\n  return ia === ib && ja === jb;\n}\n\nvar prune = function(topology) {\n  var oldObjects = topology.objects,\n      newObjects = {},\n      oldArcs = topology.arcs,\n      oldArcsLength = oldArcs.length,\n      oldIndex = -1,\n      newIndexByOldIndex = new Array(oldArcsLength),\n      newArcsLength = 0,\n      newArcs,\n      newIndex = -1,\n      key;\n\n  function scanGeometry(input) {\n    switch (input.type) {\n      case \"GeometryCollection\": input.geometries.forEach(scanGeometry); break;\n      case \"LineString\": scanArcs(input.arcs); break;\n      case \"MultiLineString\": input.arcs.forEach(scanArcs); break;\n      case \"Polygon\": input.arcs.forEach(scanArcs); break;\n      case \"MultiPolygon\": input.arcs.forEach(scanMultiArcs); break;\n    }\n  }\n\n  function scanArc(index) {\n    if (index < 0) index = ~index;\n    if (!newIndexByOldIndex[index]) newIndexByOldIndex[index] = 1, ++newArcsLength;\n  }\n\n  function scanArcs(arcs) {\n    arcs.forEach(scanArc);\n  }\n\n  function scanMultiArcs(arcs) {\n    arcs.forEach(scanArcs);\n  }\n\n  function reindexGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(reindexGeometry)}; break;\n      case \"LineString\": output = {type: \"LineString\", arcs: reindexArcs(input.arcs)}; break;\n      case \"MultiLineString\": output = {type: \"MultiLineString\", arcs: input.arcs.map(reindexArcs)}; break;\n      case \"Polygon\": output = {type: \"Polygon\", arcs: input.arcs.map(reindexArcs)}; break;\n      case \"MultiPolygon\": output = {type: \"MultiPolygon\", arcs: input.arcs.map(reindexMultiArcs)}; break;\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function reindexArc(oldIndex) {\n    return oldIndex < 0 ? ~newIndexByOldIndex[~oldIndex] : newIndexByOldIndex[oldIndex];\n  }\n\n  function reindexArcs(arcs) {\n    return arcs.map(reindexArc);\n  }\n\n  function reindexMultiArcs(arcs) {\n    return arcs.map(reindexArcs);\n  }\n\n  for (key in oldObjects) {\n    scanGeometry(oldObjects[key]);\n  }\n\n  newArcs = new Array(newArcsLength);\n\n  while (++oldIndex < oldArcsLength) {\n    if (newIndexByOldIndex[oldIndex]) {\n      newIndexByOldIndex[oldIndex] = ++newIndex;\n      newArcs[newIndex] = oldArcs[oldIndex];\n    }\n  }\n\n  for (key in oldObjects) {\n    newObjects[key] = reindexGeometry(oldObjects[key]);\n  }\n\n  return {\n    type: \"Topology\",\n    bbox: topology.bbox,\n    transform: topology.transform,\n    objects: newObjects,\n    arcs: newArcs\n  };\n};\n\nvar filter = function(topology, filter) {\n  var oldObjects = topology.objects,\n      newObjects = {},\n      key;\n\n  if (filter == null) filter = filterTrue;\n\n  function filterGeometry(input) {\n    var output, arcs;\n    switch (input.type) {\n      case \"Polygon\": {\n        arcs = filterRings(input.arcs);\n        output = arcs ? {type: \"Polygon\", arcs: arcs} : {type: null};\n        break;\n      }\n      case \"MultiPolygon\": {\n        arcs = input.arcs.map(filterRings).filter(filterIdentity);\n        output = arcs.length ? {type: \"MultiPolygon\", arcs: arcs} : {type: null};\n        break;\n      }\n      case \"GeometryCollection\": {\n        arcs = input.geometries.map(filterGeometry).filter(filterNotNull);\n        output = arcs.length ? {type: \"GeometryCollection\", geometries: arcs} : {type: null};\n        break;\n      }\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function filterRings(arcs) {\n    return arcs.length && filterExteriorRing(arcs[0]) // if the exterior is small, ignore any holes\n        ? [arcs[0]].concat(arcs.slice(1).filter(filterInteriorRing))\n        : null;\n  }\n\n  function filterExteriorRing(ring) {\n    return filter(ring, false);\n  }\n\n  function filterInteriorRing(ring) {\n    return filter(ring, true);\n  }\n\n  for (key in oldObjects) {\n    newObjects[key] = filterGeometry(oldObjects[key]);\n  }\n\n  return prune({\n    type: \"Topology\",\n    bbox: topology.bbox,\n    transform: topology.transform,\n    objects: newObjects,\n    arcs: topology.arcs\n  });\n};\n\nfunction filterTrue() {\n  return true;\n}\n\nfunction filterIdentity(x) {\n  return x;\n}\n\nfunction filterNotNull(geometry) {\n  return geometry.type != null;\n}\n\nvar filterAttached = function(topology) {\n  var ownerByArc = new Array(topology.arcs.length), // arc index -> index of unique associated ring, or -1 if used by multiple rings\n      ownerIndex = 0,\n      key;\n\n  function testGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(testGeometry); break;\n      case \"Polygon\": testArcs(o.arcs); break;\n      case \"MultiPolygon\": o.arcs.forEach(testArcs); break;\n    }\n  }\n\n  function testArcs(arcs) {\n    for (var i = 0, n = arcs.length; i < n; ++i, ++ownerIndex) {\n      for (var ring = arcs[i], j = 0, m = ring.length; j < m; ++j) {\n        var arc = ring[j];\n        if (arc < 0) arc = ~arc;\n        var owner = ownerByArc[arc];\n        if (owner == null) ownerByArc[arc] = ownerIndex;\n        else if (owner !== ownerIndex) ownerByArc[arc] = -1;\n      }\n    }\n  }\n\n  for (key in topology.objects) {\n    testGeometry(topology.objects[key]);\n  }\n\n  return function(ring) {\n    for (var j = 0, m = ring.length, arc; j < m; ++j) {\n      if (ownerByArc[(arc = ring[j]) < 0 ? ~arc : arc] === -1) {\n        return true;\n      }\n    }\n    return false;\n  };\n};\n\nfunction planarTriangleArea(triangle) {\n  var a = triangle[0], b = triangle[1], c = triangle[2];\n  return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1])) / 2;\n}\n\nfunction planarRingArea$1(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n  return Math.abs(area) / 2;\n}\n\nvar filterWeight = function(topology, minWeight, weight) {\n  minWeight = minWeight == null ? Number.MIN_VALUE : +minWeight;\n\n  if (weight == null) weight = planarRingArea$1;\n\n  return function(ring, interior) {\n    return weight(feature(topology, {type: \"Polygon\", arcs: [ring]}).geometry.coordinates[0], interior) >= minWeight;\n  };\n};\n\nvar filterAttachedWeight = function(topology, minWeight, weight) {\n  var a = filterAttached(topology),\n      w = filterWeight(topology, minWeight, weight);\n  return function(ring, interior) {\n    return a(ring, interior) || w(ring, interior);\n  };\n};\n\nfunction compare(a, b) {\n  return a[1][2] - b[1][2];\n}\n\nvar newHeap = function() {\n  var heap = {},\n      array = [],\n      size = 0;\n\n  heap.push = function(object) {\n    up(array[object._ = size] = object, size++);\n    return size;\n  };\n\n  heap.pop = function() {\n    if (size <= 0) return;\n    var removed = array[0], object;\n    if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);\n    return removed;\n  };\n\n  heap.remove = function(removed) {\n    var i = removed._, object;\n    if (array[i] !== removed) return; // invalid request\n    if (i !== --size) object = array[size], (compare(object, removed) < 0 ? up : down)(array[object._ = i] = object, i);\n    return i;\n  };\n\n  function up(object, i) {\n    while (i > 0) {\n      var j = ((i + 1) >> 1) - 1,\n          parent = array[j];\n      if (compare(object, parent) >= 0) break;\n      array[parent._ = i] = parent;\n      array[object._ = i = j] = object;\n    }\n  }\n\n  function down(object, i) {\n    while (true) {\n      var r = (i + 1) << 1,\n          l = r - 1,\n          j = i,\n          child = array[j];\n      if (l < size && compare(array[l], child) < 0) child = array[j = l];\n      if (r < size && compare(array[r], child) < 0) child = array[j = r];\n      if (j === i) break;\n      array[child._ = i] = child;\n      array[object._ = i = j] = object;\n    }\n  }\n\n  return heap;\n};\n\nfunction copy(point) {\n  return [point[0], point[1], 0];\n}\n\nvar presimplify = function(topology, weight) {\n  var point = topology.transform ? transform(topology.transform) : copy,\n      heap = newHeap();\n\n  if (weight == null) weight = planarTriangleArea;\n\n  var arcs = topology.arcs.map(function(arc) {\n    var triangles = [],\n        maxWeight = 0,\n        triangle,\n        i,\n        n;\n\n    arc = arc.map(point);\n\n    for (i = 1, n = arc.length - 1; i < n; ++i) {\n      triangle = [arc[i - 1], arc[i], arc[i + 1]];\n      triangle[1][2] = weight(triangle);\n      triangles.push(triangle);\n      heap.push(triangle);\n    }\n\n    // Always keep the arc endpoints!\n    arc[0][2] = arc[n][2] = Infinity;\n\n    for (i = 0, n = triangles.length; i < n; ++i) {\n      triangle = triangles[i];\n      triangle.previous = triangles[i - 1];\n      triangle.next = triangles[i + 1];\n    }\n\n    while (triangle = heap.pop()) {\n      var previous = triangle.previous,\n          next = triangle.next;\n\n      // If the weight of the current point is less than that of the previous\n      // point to be eliminated, use the latter’s weight instead. This ensures\n      // that the current point cannot be eliminated without eliminating\n      // previously- eliminated points.\n      if (triangle[1][2] < maxWeight) triangle[1][2] = maxWeight;\n      else maxWeight = triangle[1][2];\n\n      if (previous) {\n        previous.next = next;\n        previous[2] = triangle[2];\n        update(previous);\n      }\n\n      if (next) {\n        next.previous = previous;\n        next[0] = triangle[0];\n        update(next);\n      }\n    }\n\n    return arc;\n  });\n\n  function update(triangle) {\n    heap.remove(triangle);\n    triangle[1][2] = weight(triangle);\n    heap.push(triangle);\n  }\n\n  return {\n    type: \"Topology\",\n    bbox: topology.bbox,\n    objects: topology.objects,\n    arcs: arcs\n  };\n};\n\nvar quantile = function(topology, p) {\n  var array = [];\n\n  topology.arcs.forEach(function(arc) {\n    arc.forEach(function(point) {\n      if (isFinite(point[2])) { // Ignore endpoints, whose weight is Infinity.\n        array.push(point[2]);\n      }\n    });\n  });\n\n  return array.length && quantile$1(array.sort(descending), p);\n};\n\nfunction quantile$1(array, p) {\n  if (!(n = array.length)) return;\n  if ((p = +p) <= 0 || n < 2) return array[0];\n  if (p >= 1) return array[n - 1];\n  var n,\n      h = (n - 1) * p,\n      i = Math.floor(h),\n      a = array[i],\n      b = array[i + 1];\n  return a + (b - a) * (h - i);\n}\n\nfunction descending(a, b) {\n  return b - a;\n}\n\nvar simplify = function(topology, minWeight) {\n  minWeight = minWeight == null ? Number.MIN_VALUE : +minWeight;\n\n  // Remove points whose weight is less than the minimum weight.\n  var arcs = topology.arcs.map(function(input) {\n    var i = -1,\n        j = 0,\n        n = input.length,\n        output = new Array(n), // pessimistic\n        point;\n\n    while (++i < n) {\n      if ((point = input[i])[2] >= minWeight) {\n        output[j++] = [point[0], point[1]];\n      }\n    }\n\n    output.length = j;\n    return output;\n  });\n\n  return {\n    type: \"Topology\",\n    transform: topology.transform,\n    bbox: topology.bbox,\n    objects: topology.objects,\n    arcs: arcs\n  };\n};\n\nvar pi = Math.PI;\nvar tau = 2 * pi;\nvar quarterPi = pi / 4;\nvar radians = pi / 180;\nvar abs = Math.abs;\nvar atan2 = Math.atan2;\nvar cos = Math.cos;\nvar sin = Math.sin;\n\nfunction halfArea(ring, closed) {\n  var i = 0,\n      n = ring.length,\n      sum = 0,\n      point = ring[closed ? i++ : n - 1],\n      lambda0, lambda1 = point[0] * radians,\n      phi1 = (point[1] * radians) / 2 + quarterPi,\n      cosPhi0, cosPhi1 = cos(phi1),\n      sinPhi0, sinPhi1 = sin(phi1);\n\n  for (; i < n; ++i) {\n    point = ring[i];\n    lambda0 = lambda1, lambda1 = point[0] * radians;\n    phi1 = (point[1] * radians) / 2 + quarterPi;\n    cosPhi0 = cosPhi1, cosPhi1 = cos(phi1);\n    sinPhi0 = sinPhi1, sinPhi1 = sin(phi1);\n\n    // Spherical excess E for a spherical triangle with vertices: south pole,\n    // previous point, current point.  Uses a formula derived from Cagnoli’s\n    // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n    // See https://github.com/d3/d3-geo/blob/master/README.md#geoArea\n    var dLambda = lambda1 - lambda0,\n        sdLambda = dLambda >= 0 ? 1 : -1,\n        adLambda = sdLambda * dLambda,\n        k = sinPhi0 * sinPhi1,\n        u = cosPhi0 * cosPhi1 + k * cos(adLambda),\n        v = k * sdLambda * sin(adLambda);\n    sum += atan2(v, u);\n  }\n\n  return sum;\n}\n\nfunction sphericalRingArea(ring, interior) {\n  var sum = halfArea(ring, true);\n  if (interior) sum *= -1;\n  return (sum < 0 ? tau + sum : sum) * 2;\n}\n\nfunction sphericalTriangleArea(t) {\n  return abs(halfArea(t, false)) * 2;\n}\n\nexports.bbox = bbox;\nexports.feature = feature;\nexports.mesh = mesh;\nexports.meshArcs = meshArcs;\nexports.merge = merge;\nexports.mergeArcs = mergeArcs;\nexports.neighbors = neighbors;\nexports.quantize = quantize;\nexports.transform = transform;\nexports.untransform = untransform;\nexports.topology = topology;\nexports.filter = filter;\nexports.filterAttached = filterAttached;\nexports.filterAttachedWeight = filterAttachedWeight;\nexports.filterWeight = filterWeight;\nexports.planarRingArea = planarRingArea$1;\nexports.planarTriangleArea = planarTriangleArea;\nexports.presimplify = presimplify;\nexports.quantile = quantile;\nexports.simplify = simplify;\nexports.sphericalRingArea = sphericalRingArea;\nexports.sphericalTriangleArea = sphericalTriangleArea;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]},"metadata":{},"sourceType":"script"}